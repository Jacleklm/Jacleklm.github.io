<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jacleklm</title>
  
  
  <link href="http://jacleklm.github.io/atom.xml" rel="self"/>
  
  <link href="http://jacleklm.github.io/"/>
  <updated>2023-09-17T14:00:22.868Z</updated>
  <id>http://jacleklm.github.io/</id>
  
  <author>
    <name>Jacleklm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Basic Knowledge</title>
    <link href="http://jacleklm.github.io/2022/04/30/Python%20Basic/"/>
    <id>http://jacleklm.github.io/2022/04/30/Python%20Basic/</id>
    <published>2022-04-30T09:20:21.000Z</published>
    <updated>2023-09-17T14:00:22.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>基本来源于<a href="https://www.runoob.com/python3/python3-tutorial.html">菜鸟教程</a></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li>Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</li><li>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li></ul><ol><li>环境</li><li>需配置一些环境变量，暂不做 <a href="https://www.runoob.com/python3/python3-install.html">https://www.runoob.com/python3/python3-install.html</a></li><li>运行</li><li>python fileName.py运行</li><li>用vs code右键</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol><li>多行语句。Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句，例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">item_one = <span class="number">1</span></span><br><span class="line">item_two = <span class="number">2</span></span><br><span class="line">item_three = <span class="number">2</span></span><br><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="built_in">print</span>(total) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建；Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型</p></li><li><p>允许你同时为多个变量赋值<br>a &#x3D; b &#x3D; c &#x3D; 1<br>a, b, c &#x3D; 1, true, “demo”</p></li><li><p>Import</p></li><li><p>在 python 用 import 或者 from…import 来导入相应的模块。</p></li><li><p>将整个模块(somemodule)导入，格式为： import somemodule</p></li><li><p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p></li><li><p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p></li><li><p>将某个模块中的全部函数导入，格式为： from somemodule import *</p></li><li><p>Python3 中有六个标准的数据类型：</p></li><li><p>Number（数字）</p></li><li><p>String（字符串）</p></li><li><p>List（列表）</p></li><li><p>Tuple（元组）</p></li><li><p>Set（集合）</p></li><li><p>Dictionary（字典）</p></li><li><p>Python3 的六个标准数据类型中：</p></li><li><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br>1. 其实是指字符串中某个字符不可改变. Eg. str &#x3D; ‘abc’; str[1] &#x3D; ‘d’这种是不行的</p></li><li><p>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p></li><li><p>内置的 type() 函数 可以用来查询变量所指的对象类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line"><span class="comment"># &lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>此外还可以用 isinstance 来判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">111</span></span><br><span class="line"><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></li><li><p>使用del语句删除一个或多个对象引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>单引号 ‘ 和双引号 “  使用完全相同；使用三引号 ‘’’ 或 “”” 可以指定一个多行字符串<br>word &#x3D; ‘字符串’<br>sentence &#x3D; “这是一个句子。”<br>paragraph &#x3D; “””这是一个段落，<br>可以由多行组成”””</p></li><li><p>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始后的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])          <span class="comment"># 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)         <span class="comment"># 连接字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nrunoob&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nrunoob&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br><span class="line"></span><br><span class="line">----------------------------输出部分-------------------------------------------</span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="number">3456789</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">123456789123456789</span></span><br><span class="line"><span class="number">123456789</span>你好</span><br><span class="line">------------------------------</span><br><span class="line">hello</span><br><span class="line">runoob</span><br><span class="line">hello\nrunoob</span><br></pre></td></tr></table></figure></li><li><p>字符串函数</p></li><li><p>capitalize()：首字转大写</p></li><li><p>count(str, beg&#x3D; 0,end&#x3D;len(string))：返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</p></li><li><p>endswith(suffix, beg&#x3D;0, end&#x3D;len(string))：检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</p></li><li><p>startswith(substr, beg&#x3D;0,end&#x3D;len(string))：检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查</p></li><li><p>split(str&#x3D;””, num&#x3D;string.count(str))：以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</p></li><li><p>find(str, beg&#x3D;0, end&#x3D;len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</p></li><li><p>index(str, beg&#x3D;0, end&#x3D;len(string))：跟find()方法一样，只不过如果str不在字符串中会报一个异常</p></li><li><p>rfind(str, beg&#x3D;0,end&#x3D;len(string))：类似于 find()函数，不过是从右边开始查找</p></li><li><p>lower()：转换字符串中所有大写字符为小写</p></li><li><p>replace(old, new [, max])：把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次</p></li><li></li><li><p>isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</p></li><li><p>isalpha()：如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</p></li><li><p>isdigit()：如果字符串只包含数字则返回 True 否则返回 False.</p></li><li></li></ol><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>python中数字有四种类型：整数int、布尔型bool（？？）、浮点数float和复数complex</p><ol><li>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加。True&#x3D;&#x3D;1、False&#x3D;&#x3D;0 会返回 True，但可以通过 is 来判断类型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>==<span class="number">1</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span>)</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></li><li>数字运算<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></li><li>数学函数</li><li>abs(x) 绝对值</li><li>ceil(x) 向上取整</li><li>floor(x) 向下取整</li><li>round(x [,n]) 浮点数x的四舍五入</li><li>exp(x) 常数e的x次幂</li><li>pow(x, y) x^y</li><li>sqrt(x) x的平方根</li><li>max(a, b, c…) 最大值</li><li>min(a, b, c…) 最小值</li><li>随机数函数</li><li>choice(seq): 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数</li><li>randrange ([start,] stop [,step]): 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</li><li>random(): 随机生成下一个实数，它在[0,1)范围内</li><li>shuffle(lst): 将序列的所有元素随机排序</li><li>uniform(x, y): 随机生成下一个实数，它在[x,y]范围内</li></ol><h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><ol><li>基础<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)       <span class="comment"># 输出完整列表 [&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])      <span class="comment"># 输出列表第一个元素  abcd</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])     <span class="comment"># 从第二个开始输出到第三个元素 [786, 2.23]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])     <span class="comment"># 输出从第三个元素开始的所有元素 [2.23, &#x27;runoob&#x27;, 70.2]</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)   <span class="comment"># 输出两次列表 [123, &#x27;runoob&#x27;, 123, &#x27;runoob&#x27;]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表 [&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2, 123, &#x27;runoob&#x27;]</span></span><br></pre></td></tr></table></figure></li><li>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 (包含开始，不包含结束)的位置并设置为步长为 2（间隔一个位置）来截取字符串：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(letters[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]) <span class="comment"># [&#x27;a&#x27;, &#x27;l&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(letters[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># [&#x27;a&#x27;, &#x27;l&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(letters[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]) <span class="comment"># [&#x27;a&#x27;, &#x27;l&#x27;, &#x27;k&#x27;]</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串（有一说一不好理解）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="built_in">input</span> = <span class="string">&#x27;I like python&#x27;</span></span><br><span class="line">rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(rw) <span class="comment"># python like I</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>常用方法</li><li>list.append(1) 。添加元素 1</li><li>list.insert(idx, obj)</li><li>list.pop([idx&#x3D;-1])</li><li>list.remove(obj)</li><li>del list[3] 删除idx 3元素</li><li>list.count(obj) 元素出现的次数</li><li>list.index(obj) 返回idx</li><li>list.reverse()</li><li>list.sort( key&#x3D;None, reverse&#x3D;False)：排序</li><li>list.clear()</li><li>list.copy()</li><li>List 间 的 + ，是组合</li><li>list * 某个num，是重复几次</li><li>for x in [1, 2, 3]: print(x, end&#x3D;” “)。迭代</li></ol><h2 id="Tuple元组"><a href="#Tuple元组" class="headerlink" title="Tuple元组"></a>Tuple元组</h2><ol><li>元组（tuple）与列表类似，不同之处在于元组的元素不能修改（像 tup[0] &#x3D; 11 这种是不允许的），也不能删除某个元素。元组写在小括号 () 里，元素之间用逗号隔开<br>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表<br>string、list 和 tuple 都属于 sequence（序列）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)        <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])      <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])     <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)    <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line">abcd(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line">(<span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line">(<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>包含0个或1个元素的元组，语法比较特殊：<br>tup1 &#x3D; ()    # 空元组<br>tup2 &#x3D; (20,) # 一个元素，需要在元素后添加逗号</li></ol><p>Set（集合）</p><ol><li>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。基本功能是进行成员关系测试和删除重复元素。</li><li>可以使用大括号 { } 或者 set() 函数创建集合<br>注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。<br>sites &#x3D; {‘Google’, ‘Taobao’, ‘Google’, ‘Facebook’, ‘Zhihu’, ‘Baidu’}<br>print(sites)   # 输出集合，重复的元素被自动去掉 {‘Baidu’, ‘Facebook’, ‘Google’, ‘Zhihu’, ‘Taobao’}</li></ol><h2 id="成员测试"><a href="#成员测试" class="headerlink" title="成员测试"></a>成员测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;RuGooglenoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>) <span class="comment"># Runoob 不在集合中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a - b)    <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="built_in">print</span>(a | b)    <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)    <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)    <span class="comment"># a 和 b 中不同时存在的元素</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>常见方法</li><li>set.add()</li><li>set.clear()</li><li>set.copy()</li><li>remove() 移除指定元素</li><li>difference() 返回多个集合的差集</li><li>intersection() 返回集合的交集</li><li>discard() 删除集合中指定的元素<br>Dictionary（字典）</li><li>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</li><li>键(key)必须使用不可变类型；在同一个字典中，键(key)必须是唯一的。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 菜鸟教程&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]    = <span class="string">&quot;2 - 菜鸟工具&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">dict3(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>) <span class="comment"># &#123;&#x27;sape&#x27;: 4139, &#x27;jack&#x27;: 4098, &#x27;guido&#x27;: 4127&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])     <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])       <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)      <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> - 菜鸟教程</span><br><span class="line"><span class="number">2</span> - 菜鸟工具</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line">dict_keys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;site&#x27;</span>])</span><br><span class="line">dict_values([<span class="string">&#x27;runoob&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li>常用方法</li><li>len()。返回键的总数</li><li>str(dict)。输出字典字符串</li><li>dict.clear()</li><li>dict.copy()</li><li>dict.get(key)</li><li>dict.setdefault(key, default&#x3D;None): 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li><li>key in dict: 如果键在字典dict里返回true，否则返回false</li><li>dict.keys()</li><li>dict.items(): 以列表返回一个视图对象.eg. 返回 dict_items([(‘Name’, ‘Runoob’), (‘Age’, 7), (‘Class’, ‘First’)])</li><li>dict.values()</li><li>dict.update(dict2): 把字典dict2的键&#x2F;值对更新到dict里</li><li>pop(key[,default]): 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值</li><li>popitem(): 返回并删除字典中的最后一对键和值<br>Python数据类型转换<br><a href="https://www.runoob.com/python3/python3-type-conversion.html">https://www.runoob.com/python3/python3-type-conversion.html</a></li></ol><ul><li>隐式类型转换。我们对两种不同类型的数据进行运算，较低数据类型（eg. 整数）就会转换为较高数据类型（eg. 浮点数）以避免数据丢失<ul><li>当然也有转换不了的。eg. 整型数据与字符串类型的数据进行相加，会报错因为转换不了</li></ul></li><li>显式类型转换。 int()、float()、str() 等<br>Python 推导式<br>推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构，支持list、dict、set、tuple推导式</li></ul><ol><li>list推导式<br>[out_exp_res for out_exp in input_list]<br>或者<br>[out_exp_res for out_exp in input_list if condition]</li></ol><ul><li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li><li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li><li>if condition：条件语句，可以过滤列表中不符合条件的值<br>整体含义：执行后面的for 和 if 部分，满足的条件的就执行 out_exp_res 部分产出最后结果<br>例子：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br><span class="line"><span class="comment"># [&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>Dict推导式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line">或</span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure>同理，看这个case即能理解：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="built_in">print</span>(newdict)</span><br><span class="line"><span class="comment"># &#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure></li><li>Set推导式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure></li><li>元组tuple推导式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure></li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li>运算符。除了常规的，还有</li><li>** 为幂。a**b 为 a^b</li><li>&#x2F;&#x2F; 为取整除。eg. 9&#x2F;&#x2F;2 &#x3D;&#x3D; 4</li><li>:&#x3D; 为海象运算符，一般用在表达式内部为变量赋值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;List is too long (<span class="subst">&#123;n&#125;</span> elements, expected &lt;= 10)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个if即判断了 if (len(a)) &gt; 10, 又把 n 赋值为 len(a)</span></span><br></pre></td></tr></table></figure></li><li>逻辑运算符（不是 ||、&amp;&amp;、! 这样），是：and、or、not</li><li>成员运算符：in、not in</li><li>身份运算符：is、not is</li><li>运算符优先级。略</li></ol><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fibonacci series: 斐波纳契数列</span></span><br><span class="line"><span class="comment"># 两个元素的总和确定了下一个数</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">1000</span>:</span><br><span class="line">    <span class="built_in">print</span>(b, end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line"><span class="comment"># 结果：1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</span></span><br></pre></td></tr></table></figure><p>循环</p><ol><li>While<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> counter &lt;= n:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + counter</span><br><span class="line">    counter += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li>For<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li><li>range()。如果你需要遍历数字序列，可以使用内置range()函数，它会生成数列。eg：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’).eg. for i in range(0, 10, 3) 。0到10，每步为3</li></ul><ol start="4"><li>pass 语句。Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Runoob&#x27;</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;执行 pass 块&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前字母 :&#x27;</span>, letter)</span><br><span class="line"> <span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： </span></span><br><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">执行 <span class="keyword">pass</span> 块</span><br><span class="line">当前字母 : o</span><br><span class="line">执行 <span class="keyword">pass</span> 块</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : b</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></li></ol><h2 id="迭代器-与-生成器"><a href="#迭代器-与-生成器" class="headerlink" title="迭代器 与 生成器"></a>迭代器 与 生成器</h2><ol><li>迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退</li><li>迭代器有两个基本的方法：iter() 和 next()</li><li>字符串，列表或元组对象都可用于创建迭代器<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素 # 1</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li><li>生成器 yield。在 Python 中，使用了 yield 的函数被称为生成器（generator）。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象<br>函数<br>函数以 def 开头，而不是func或function这种，而且也没有 { } 这种边界，完全考层级肉眼区分</li><li>参数</li><li>默认参数。和 js 一致</li><li>不定长参数。<br>1. 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printMoreArgs</span>(<span class="params">a, *morArgs</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;a is&quot;</span>, a)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;morArgs is&quot;</span>, morArgs) <span class="comment"># morArgs is (5, 6, &#x27;jacle&#x27;)</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(morArgs)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">printMoreArgs(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;jacle&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><pre><code>1. 加了两个星号 ** 的参数会以字典的形式导入</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jacle&#x27;, &#x27;age&#x27;: &#x27;21&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">1</span>, name=<span class="string">&#x27;jacle&#x27;</span>,age=<span class="string">&#x27;21&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>匿名函数。Python 使用 lambda 来创建匿名函数。语法如下<br><code>lambda [arg1 [,arg2,.....argn]]:expression</code></li></ol><p>Eg.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">lambda</span> a : a + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>模块</p><ol><li>import<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line"></span><br><span class="line">module.method(args)</span><br></pre></td></tr></table></figure></li><li>from … import<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> method1[, method2[, ... methodN]]</span><br></pre></td></tr></table></figure></li><li>from … import *   把一个模块的所有内容全都导入到当前的命名空间</li><li>__name__属性。每个模块都有这个属性，用来识别该模块是「自身在运行」，还是「被引用后」在运行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path: ./mod1.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br></pre></td></tr></table></figure>直接运行 python .&#x2F;mod1，会打印出 程序自身在运行；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># path: ./mod2.py</span></span><br><span class="line"><span class="keyword">import</span> mod1</span><br></pre></td></tr></table></figure>若是被其他模块引用后运行，则打印出 我来自另一模块<br>命名空间和作用域链<br>感觉和js差不多<br>面向对象<br>用class关键字创建类<br>错误和异常</li><li>try&#x2F;expcept语句</li><li>try&#x2F;expcept…else语句<br>常用功能<br>输入输出<br>正则<br>JSON<br>日期和时间<br>File<br>OS</li></ol><p><a href="https://www.runoob.com/python3/python3-function.html">https://www.runoob.com/python3/python3-function.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;基本来源于&lt;a href=&quot;https://www.runoob.com/python3/python3-tutorial.html&quot;&gt;菜鸟</summary>
      
    
    
    
    <category term="Python" scheme="http://jacleklm.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://jacleklm.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决hexo g生成index.html为空的问题</title>
    <link href="http://jacleklm.github.io/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://jacleklm.github.io/2021/04/17/%E8%A7%A3%E5%86%B3hexo%20g%E7%94%9F%E6%88%90index.html%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-17T12:33:46.000Z</published>
    <updated>2023-09-17T14:00:22.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近一段时间博客通过域名访问的方式一直访问为空白页面，我以为是github的问题过段时间就好了，就没太管，后来一直没恢复，于是查了下是什么原因。刚开始以为是githubpage的问题，往这个方向折腾了好久没啥结果… 不过也知道到了 <code>username.github.io</code> 下可以通过路由的方式部署多个项目，问题没解决不过也没白折腾吧。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最终发现是之前没管的hexo的循环依赖问题：<br><code>hexo -s</code>预览博客的时候出现循环引用的报错：<code>hexo (node:7801) Warning: Accessing non-existent property &#39;filename&#39;...</code>。目前社区上认为是node版本较新导致了，回退node版本即可。于是安装了<code>n</code>进行node版本管理。(回退到 v12.16.2 就没问题了) </p><blockquote><p>用 nvm 管理 node 版本也可</p></blockquote><h1 id="n的常用命令"><a href="#n的常用命令" class="headerlink" title="n的常用命令"></a>n的常用命令</h1><ul><li>利用 n 下载所需node: <code>$ n 版本号</code></li><li>下载最新版本: <code>$ n latest</code></li><li>下载稳定版: <code>$ n stable</code></li><li>删除某个版本: <code>$ n rm 4.4.4</code></li><li>查看当前 node 版本: <code>$ node -v</code></li><li>切换版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ n</span><br><span class="line">  <span class="number">6.9</span><span class="number">.4</span></span><br><span class="line">ο <span class="number">7.4</span><span class="number">.0</span></span><br><span class="line">  <span class="number">4.4</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></li><li>以指定的版本来执行脚本: <code>$ n use 7.4.0 index.js</code>ç</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近一段时间博客通过域名访问的方式一直访问为空白页面，我以为是github的问题过段时间就好了，就没太管，后来一直没恢复，于是查了下是什么原</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="工具" scheme="http://jacleklm.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的内置工具类型及其实现</title>
    <link href="http://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-12-09T09:25:21.000Z</published>
    <updated>2023-09-17T14:00:22.870Z</updated>
    
    <content type="html"><![CDATA[<p>先来看下基础实现 clone，把 T 里面的都拷贝一次：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cloneT&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>将类型定义的所有属性<strong>都修改为可选</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Foo</span>&gt;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类似Partial的实现，还有-Required，Readonly"><a href="#类似Partial的实现，还有-Required，Readonly" class="headerlink" title="类似Partial的实现，还有 Required，Readonly"></a>类似Partial的实现，还有 Required，Readonly</h1><p>Required 的作用是将传入的属性变为必选项, Readonly是将所有属性定义为自读，源码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; </span><br><span class="line">  [K <span class="keyword">in</span> keyof T]-?: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类似 <code>-?</code>, <code>readonly</code>, 同理还有 <code>-readonly</code></p></blockquote><h1 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>以 typeof 格式快速创建一个类型，此类型包含一组指定的属性且<strong>都是必填</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><h1 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h1><p>不管是从字面意思，还是定义上都很好理解：将所有属性定义为自读</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进行了修改，则会报错：</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: <span class="title class_">Coord</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line">c.<span class="property">x</span> = <span class="number">2</span>; <span class="comment">// Error: Cannot assign to &#x27;x&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure><h1 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h1><p>从类型定义的属性中，选取指定一组属性，返回一个新的类型定义。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Coord</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CoordX</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Coord</span>, <span class="string">&#x27;x&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等用于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CoordX</span> = &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个很实用的实现就是 clone，把 T 里面的都拷贝一次</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cloneT&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>重要的就是这个in操作符，你完全可以把它理解为就是for…in，也就包含了遍历的过程</p><h1 id="Partial-1"><a href="#Partial-1" class="headerlink" title="Partial"></a>Partial</h1><p>clone再可选</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文献</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来看下基础实现 clone，把 T 里面的都拷贝一次：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="http://jacleklm.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的类型编程</title>
    <link href="http://jacleklm.github.io/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://jacleklm.github.io/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2020-12-07T09:25:21.000Z</published>
    <updated>2023-09-17T14:00:22.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章是读了林不渡的<a href="https://juejin.cn/post/6885672896128090125#heading-0">TypeScript 的另一面：类型编程</a>，码了一些 demo 并查了其他文档等最后留下的学习笔记。建议直接读原文，本文可读性较差</p><h2 id="类型编程的特点-看法"><a href="#类型编程的特点-看法" class="headerlink" title="类型编程的特点&#x2F;看法"></a>类型编程的特点&#x2F;看法</h2><ul><li>它会带来代码量大大增多（可能接近甚至超过业务代码），编码耗时增长等问题，而带来的唯一好处就是<strong>类型安全</strong>，包括的类型提示，进一步减少可能存在的调用错误，以及降低维护成本。看起来似乎有得有失，但实际上，假设你花费 1 单位脑力使用基础的 TS 以及简单的类型编程，你就能够获得 5 个单位的回馈。但接下来，有可能你花费 10 个单位脑力，也只能再获得 2 个单位的回馈</li><li>另外一个类型编程不受重视的原因则是实际业务中并不会需要多么苛刻的类型定义，通常是底层框架类库才会有此类需求</li></ul><h1 id="泛型-Generic-Type"><a href="#泛型-Generic-Type" class="headerlink" title="泛型 Generic Type"></a>泛型 Generic Type</h1><p>见<a href="https://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript 基础语法小结</a></p><blockquote><p>在类型编程里，泛型就是变量</p></blockquote><p>比如我们要写一个类似于 Pick 功能的函数，从一个 obj 中挑选一些键值对出来，可以这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> getValueListOfObj&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">keys</span>: U[]): T[U][] &#123;</span><br><span class="line">  <span class="keyword">return</span> keys.<span class="title function_">map</span>(<span class="function">(<span class="params">key: U</span>) =&gt;</span> obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还用 extends 做了一定的泛型约束</p><h1 id="索引类型与映射类型"><a href="#索引类型与映射类型" class="headerlink" title="索引类型与映射类型"></a>索引类型与映射类型</h1><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>索引类型见<a href="https://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript 基础语法小结</a></p><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>映射类型 Mapped Types 通常用于在旧有类型的基础上进行改造，包括接口包含字段、字段的类型、修饰符（readonly 与?）等等。可以利用 Readonly，Partial 等这些 TS 内置<strong>工具类型</strong>(也叫类型接口)实现这个过程。</p><blockquote><p>简单地说就是 TS 允许将一个类型映射成另外一个类型</p></blockquote><p>一个很实用的实现就是 clone，把 T 里面的都拷贝一次</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cloneT&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面这种已经算是工具类型的实现了。相当于类型编程中的 utils</p></blockquote><p>这部分详见 <a href="https://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/9">TypeScript 中的内置工具类型及其实现</a></p><h1 id="条件类型-Conditional-Types"><a href="#条件类型-Conditional-Types" class="headerlink" title="条件类型 Conditional Types"></a>条件类型 Conditional Types</h1><p>条件类型的语法实际上就是三元表达式。其中一个常见应用就是用来实现更精准的泛型约束，<strong>使得泛型收窄</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends U ? X : Y</span><br></pre></td></tr></table></figure><blockquote><p>这种场景下 T 一般是联合类型。如果你觉得这里的 extends 不太好理解，可以暂时简单理解为 U 中的属性在 T 中都有</p></blockquote><p>条件类型理解起来更直观，唯一需要有一定理解成本的就是<strong>何时条件类型系统会收集到足够的信息来确定类型</strong>，也就是说，条件类型有可能不会被立刻完成判断。<br>有时候，条件类型的推导会被延迟（deferred），因为此时类型系统没有足够的信息来完成判断：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单纯声明而已</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> strOrNum&lt;T <span class="keyword">extends</span> <span class="built_in">boolean</span>&gt;(<span class="attr">input</span>: T): T <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p>只有给出了所需信息（在这里是input值），才可以完成推导</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strReturnType = <span class="title function_">strOrNum</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="嵌套的条件类型"><a href="#嵌套的条件类型" class="headerlink" title="嵌套的条件类型"></a>嵌套的条件类型</h2><p>此外，就像三元表达式可以嵌套，条件类型也可以嵌套，如果你看过一些框架源码，也会发现其中存在着许多嵌套的条件类型，条件类型可以将类型约束收拢到非常精确的范围内</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">  ? <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">    ? <span class="string">&#x27;number&#x27;</span></span><br><span class="line">    : T <span class="keyword">extends</span> <span class="built_in">boolean</span></span><br><span class="line">      ? <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">      : T <span class="keyword">extends</span> <span class="literal">undefined</span></span><br><span class="line">        ? <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">        : T <span class="keyword">extends</span> <span class="title class_">Function</span></span><br><span class="line">          ? <span class="string">&#x27;function&#x27;</span></span><br><span class="line">          : <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">good</span>: <span class="title class_">TypeName</span>&lt;<span class="built_in">number</span>&gt; = <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bad</span>: <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>&gt; = <span class="string">&#x27;number&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="分布式条件类型-Distributive-Conditional-Types"><a href="#分布式条件类型-Distributive-Conditional-Types" class="headerlink" title="分布式条件类型 Distributive Conditional Types"></a>分布式条件类型 Distributive Conditional Types</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>分布式条件类型实际上不是一种特殊的条件类型，而是其特性之一。概括地说，就是<strong>对于属于裸类型参数的检查类型，条件类型会在实例化时期自动分发到联合类型上</strong></p><blockquote><p>原文: Conditional types in which the checked type is a <strong>naked type parameter</strong> are called distributive conditional types.  Distributive conditional types are automatically <strong>distributed over union types</strong> during instantiation</p></blockquote><h3 id="不负责任可能不太准确的简介"><a href="#不负责任可能不太准确的简介" class="headerlink" title="不负责任可能不太准确的简介"></a>不负责任可能不太准确的简介</h3><p>对这样一个场景：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> someTypeName&lt;T&gt; = T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>若<code>T</code>为联合类型且<code>T</code>不被包裹，则<code>T</code>中的项会被拆开分别做<code>extends U</code>判断，再把结果合并组成一个联合类型作为推断结果</p><p>抽象起来就是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( A | B | C ) <span class="keyword">extends</span> U ? X : Y</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">(A <span class="keyword">extends</span> U ? X : Y) | (B <span class="keyword">extends</span> U ? X : Y) | (B <span class="keyword">extends</span> U ? X : Y)</span><br></pre></td></tr></table></figure><h3 id="正确版的理清概念"><a href="#正确版的理清概念" class="headerlink" title="正确版的理清概念"></a>正确版的理清概念</h3><p>先提取几个关键词，然后我们再通过例子理清这个概念：</p><ul><li>裸类型参数</li><li>实例化</li><li>分发到联合类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面的TypeName类型别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;function&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;object&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>[] | <span class="built_in">number</span>[]&gt;</span><br></pre></td></tr></table></figure><p>我们发现在上面的例子里，条件类型的推导结果都是联合类型（T3实际上也是，只不过相同所以被合并了），并且就是类型参数被依次进行条件判断的结果。<br>但是当我们这样做：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Naked</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Wrapped</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">boolean</span>] ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 先分发到 Naked&lt;number&gt; | Naked&lt;boolean&gt;</span></span><br><span class="line"><span class="comment"> * 结果是 &quot;N&quot; | &quot;Y&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Distributed</span> = <span class="title class_">Naked</span>&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不会分发 直接是 [number | boolean] extends [boolean]</span></span><br><span class="line"><span class="comment"> * 然后结果是 &quot;N&quot;</span></span><br><span class="line"><span class="comment"> * 在这两个例子中，T 都是 number | boolean。区别是 T 有没有被【包裹】过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NotDistributed</span> = <span class="title class_">Wrapped</span>&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span>&gt;; </span><br></pre></td></tr></table></figure><p>现在我们可以来讲讲这几个概念了：</p><ul><li><strong>裸类型参数</strong>，没有额外被接口&#x2F;类型别名包裹过的，就像被Wrapped包裹后就不能再被称为裸类型参数。</li><li><strong>实例化</strong>，其实就是条件类型的判断过程，在这里两个例子的实例化过程实际上是不同的，具体会在下一点中介绍。</li><li><strong>分发至联合类型的过程</strong>：<br>对于TypeName，它内部的类型参数T是没有被包裹过的，所以<br><code>TypeName&lt;string | (() =&gt; void)&gt;</code> 会被分发为 <code>TypeName&lt;string&gt; | TypeName&lt;(() =&gt; void)&gt;</code>, 然后再次进行判断，最后分发为<code>&quot;string&quot; | &quot;function&quot;</code><br>抽象下具体过程：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( A | B | C ) <span class="keyword">extends</span> T ? X : Y</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">(A <span class="keyword">extends</span> T ? X : Y) | (B <span class="keyword">extends</span> T ? X : Y) | (B <span class="keyword">extends</span> T ? X : Y)</span><br></pre></td></tr></table></figure></li></ul><p>一句话概括：没有被额外包装的联合类型参数T，在条件类型进行判定时会<strong>将联合类型</strong>分发，分别进行判断。</p><h1 id="infer关键字"><a href="#infer关键字" class="headerlink" title="infer关键字"></a><a href="https://jkchao.github.io/typescript-book-chinese/tips/infer.html#%E4%BB%8B%E7%BB%8D">infer关键字</a></h1><p>infer是inference的缩写，通常的使用方式是<code>infer R</code>，<code>R</code>表示 <strong>待推断的类型</strong>。通常infer不会被直接使用，而是被放置在底层工具类型中，需要在条件类型中使用<br>看一个简单的例子，用于获取函数返回值类型的工具类型<code>ReturnType</code>，其用法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getStr = (): <span class="function"><span class="params">string</span> =&gt;</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> fn = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getStr&gt;; <span class="comment">// 推断结果是 &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p><code>ReturnType</code>源码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>infer R</code>就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用。相当于预留一个变量来存函数的返回类型<br>类似前端中的loading占位符，infer也是这个思路，<strong>类型系统在获得足够的信息后，就能将infer后跟随的类型参数推导出来</strong>，最后返回这个推导结果</p><h1 id="类型守卫-类型保护-Type-Guards-is、in-关键字"><a href="#类型守卫-类型保护-Type-Guards-is、in-关键字" class="headerlink" title="类型守卫(类型保护)Type Guards &amp;&amp; is、in 关键字"></a>类型守卫(类型保护)Type Guards &amp;&amp; is、in 关键字</h1><p>见<a href="https://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/">TypeScript 基础语法小结</a></p><h1 id="工具类型Tool-Type-及其实现"><a href="#工具类型Tool-Type-及其实现" class="headerlink" title="工具类型Tool Type 及其实现"></a>工具类型Tool Type 及其实现</h1><p>工具类型就像我们自己的util或者我们用的lodash一样，虽然即使你还是不太懂这些工具类型的底层实现，也不影响你把它用好，不够我们自己还是得了解下比较好。推荐在完成学习后记录你觉得比较有价值的工具类型，并在自己的项目里新建一个<code>.d.ts</code>文件存储它</p><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p><a href="https://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a></p><h2 id="社区工具类型"><a href="#社区工具类型" class="headerlink" title="社区工具类型"></a>社区工具类型</h2><p>参考资料<br><a href="https://juejin.cn/post/6885672896128090125#heading-0">TypeScript 的另一面：类型编程</a><br><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a><br>组内分享: TS 最佳实践</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章是读了林不渡的&lt;a href=&quot;https://juejin.cn/post/6885672896128090125#heading</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="http://jacleklm.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>hope statistics puppeteer 工具小结</title>
    <link href="http://jacleklm.github.io/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/"/>
    <id>http://jacleklm.github.io/2020/11/03/hope%20statistics%20puppeteer%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/</id>
    <published>2020-11-03T15:04:21.000Z</published>
    <updated>2023-09-17T14:00:22.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h1><p><a href="https://github.com/puppeteer/puppeteer#readme">Puppeteer</a> 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具。Chrome 作为浏览器市场的领头羊，Chrome Headless 将成为 web 应用 <strong>自动化测试</strong> 的行业标杆</p><blockquote><p>Headless浏览器是指没有窗口的浏览器</p></blockquote><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>通过 Puppeteer 我们可以让浏览器帮我们自动完成很多事情, 例如 ：</p><ul><li>生成页面的截图或者PDF</li><li>自动表单提交 (模拟登陆等)，UI测试，键盘输入</li><li>创建自动化测试环境</li></ul><p>具体API见<a href="https://github.com/puppeteer/puppeteer/blob/v5.4.1/docs/api.md#pageevalselector-pagefunction-args">官方文档</a></p><h1 id="hope-statistics-puppeteer"><a href="#hope-statistics-puppeteer" class="headerlink" title="hope statistics puppeteer"></a>hope statistics puppeteer</h1><p>一个基于 puppeteer 和 node 编写的小工具，用于统计工作室成员当月的日志、笔记、小结数目，代码见<a href="https://github.com/Jacleklm/hope-statistics-puppeteer">仓库</a></p><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>考虑到需要的输入并不复杂，交互方面直接用了 <a href="http://nodejs.cn/api/readline.html">readline</a> 模块。涉及到更多输入的可用<a href="https://www.npmjs.com/package/prompt">prompt</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入当前的年份和月份，然后按回车键结束。eg: 202010    &#x27;</span>, <span class="function">(<span class="params">month</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入本月小结会的月份和日期，然后按回车键结束。eg: 1130    &#x27;</span>, <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据统计中, 请勿触碰键盘...&#x27;</span>);</span><br><span class="line">    <span class="title function_">app</span>(<span class="title class_">Number</span>(month), <span class="title class_">Number</span>(date));</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="计算当月任务量"><a href="#计算当月任务量" class="headerlink" title="计算当月任务量"></a>计算当月任务量</h2><p>由于每月要求的日志、学习笔记数量都是不定的，这里调用了一个 <a href="https://www.kancloud.cn/xiaoggvip/holiday_free/1606802">免费API</a> ，用于获取当月的<strong>法定节假日情况</strong>，再封装成一个 getTask 方法完成这部分计算</p><h2 id="日志、笔记、小结数爬取"><a href="#日志、笔记、小结数爬取" class="headerlink" title="日志、笔记、小结数爬取"></a>日志、笔记、小结数爬取</h2><p>这里用了 puppeteer 提供的爬虫的功能，直接进行页面爬取并计算，具体见代码</p><p>参考资料<br>了解Puppeteer[<a href="https://juejin.im/post/6844903564880379912]">https://juejin.im/post/6844903564880379912]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Puppeteer&quot;&gt;&lt;a href=&quot;#Puppeteer&quot; class=&quot;headerlink&quot; title=&quot;Puppeteer&quot;&gt;&lt;/a&gt;Puppeteer&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/puppeteer/pupp</summary>
      
    
    
    
    <category term="Engineering" scheme="http://jacleklm.github.io/categories/Engineering/"/>
    
    
    <category term="Node" scheme="http://jacleklm.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>用 node.js 开发一个可交互的命令行应用</title>
    <link href="http://jacleklm.github.io/2020/11/03/%E7%94%A8%20node.js%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/"/>
    <id>http://jacleklm.github.io/2020/11/03/%E7%94%A8%20node.js%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/</id>
    <published>2020-11-03T15:02:21.000Z</published>
    <updated>2023-09-17T14:00:22.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原生-node"><a href="#原生-node" class="headerlink" title="原生 node"></a>原生 node</h1><ul><li>用 process.argv 直接读取</li><li>process.stdin.on 劫持输入</li><li><a href="http://nodejs.cn/api/readline.html">readline</a> 模块 进行逐行读取。该模块提供了一个接口，用于一次一行地读取可读流（例如 <code>process.stdin</code>）中的数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入当前的年份和月份，然后按回车键。eg: 202010. &#x27;</span>, <span class="function">(<span class="params">month</span>) =&gt;</span> &#123;</span><br><span class="line">  rl.<span class="title function_">question</span>(<span class="string">&#x27;请输入本月小结会的月份和日期，然后按回车键。eg: 1130. &#x27;</span>, <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据统计中, 请勿触碰键盘...&#x27;</span>);</span><br><span class="line">    <span class="title function_">app</span>(month, date);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一旦调用此代码，Node.js 应用程序将不会终止，直到 readline.Interface 关闭（ rl.close() ），因为接口在 input 流上等待接收数据</span></span><br><span class="line">    <span class="comment">// rl.close();</span></span><br><span class="line"></span><br><span class="line">    rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="comment">// close事件，ctrl + C 也会触发。详见 http://nodejs.cn/api/readline.html</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Goodbye 👋&quot;</span>);</span><br><span class="line">      <span class="comment">// exit the process</span></span><br><span class="line">      process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="借助-prompt-包"><a href="#借助-prompt-包" class="headerlink" title="借助 prompt 包"></a>借助 prompt 包</h1><p>如果你 打算在Node.js中构建可靠的CLI工具，则 <a href="https://www.npmjs.com/package/prompt">prompt</a> 可能是一个很好的选择。比readline更好用。<br>能像处理页面表单一样处理命令行输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> prompt = <span class="built_in">require</span>(<span class="string">&#x27;prompt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start the prompt</span></span><br><span class="line">prompt.<span class="title function_">start</span>();</span><br><span class="line"><span class="comment">// define properties schemavar schema = &#123;</span></span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: &#123;</span><br><span class="line">            <span class="attr">pattern</span>: <span class="regexp">/^[a-zA-Z\s\-]+$/</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;Name must be only letters, spaces, or dashes&#x27;</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">password</span>: &#123;</span><br><span class="line">            <span class="attr">hidden</span>: <span class="literal">true</span>  <span class="comment">// 这里能隐藏密码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask user for the input</span></span><br><span class="line">prompt.<span class="title function_">get</span>(schema, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print user credentials</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;result.name&#125;</span> / <span class="subst">$&#123;result.password&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>借助 Commander 包<br>这个感觉更像是封装命令行命令了，不仅仅是初始化时读取输入<br>代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">version</span>(<span class="string">&#x27;0.0.1&#x27;</span>)  <span class="comment">// node index --version 或 node index -V 能打印出我们定义的版本号。相当于 -V 和 -h 是自带的，其他的可以通过 .option() 来自定义</span></span><br><span class="line">  .<span class="title function_">option</span>(<span class="string">&#x27;-l, --list [list]&#x27;</span>, <span class="string">&#x27;list of customers in CSV file&#x27;</span>) <span class="comment">// 自定义的</span></span><br><span class="line">  .<span class="title function_">parse</span>(process.<span class="property">argv</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(program.<span class="property">list</span>);</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; node index --version 或 node index -V 能打印出我们定义的版本号</span><br><span class="line"><span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">&gt; node index --help</span><br><span class="line"><span class="title class_">Usage</span>: index [options]</span><br><span class="line"><span class="title class_">Options</span>:</span><br><span class="line">  -V, --version      output the version number</span><br><span class="line">  -l, --list [list]  list <span class="keyword">of</span> customers <span class="keyword">in</span> <span class="variable constant_">CSV</span> file</span><br><span class="line">  -h, --help         display help <span class="keyword">for</span> command</span><br></pre></td></tr></table></figure><p>参考资料<br><a href="https://blog.csdn.net/ccf19881030/article/details/109111128">如何从Node.js中的命令行读取输入</a><br><a href="https://juejin.im/entry/6844903474316967950">用 node.js 开发一个可交互的命令行应用: commander</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原生-node&quot;&gt;&lt;a href=&quot;#原生-node&quot; class=&quot;headerlink&quot; title=&quot;原生 node&quot;&gt;&lt;/a&gt;原生 node&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;用 process.argv 直接读取&lt;/li&gt;
&lt;li&gt;process.stdin.o</summary>
      
    
    
    
    <category term="Engineering" scheme="http://jacleklm.github.io/categories/Engineering/"/>
    
    
    <category term="Node" scheme="http://jacleklm.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出Node.js》读书笔记</title>
    <link href="http://jacleklm.github.io/2020/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://jacleklm.github.io/2020/07/15/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-15T15:02:21.000Z</published>
    <updated>2023-09-17T14:00:22.875Z</updated>
    
    <content type="html"><![CDATA[<p>感受：这本书更偏向于讲 NodeJS 的大纲和原理。所以本笔记只讲原理和case，对于API不熟的请翻<a href="http://nodejs.cn/api/">文档</a>，或看<a href="https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/fs.md">小卡的笔记</a>, 或看<a href="https://blog.poetries.top/node-learning-notes/">poetries的笔记</a> </p><h1 id="第一章-Node-简介"><a href="#第一章-Node-简介" class="headerlink" title="第一章 Node 简介"></a>第一章 Node 简介</h1><h2 id="Chrome-浏览器的组成和-Node-的组件组成"><a href="#Chrome-浏览器的组成和-Node-的组件组成" class="headerlink" title="Chrome 浏览器的组成和 Node 的组件组成"></a>Chrome 浏览器的组成和 Node 的组件组成</h2><p><img src="/img/Node/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8CNode%E7%9A%84%E7%BB%84%E4%BB%B6%E7%BB%84%E6%88%90.png"></p><h2 id="Node-的特点"><a href="#Node-的特点" class="headerlink" title="Node 的特点"></a>Node 的特点</h2><ul><li>异步 I&#x2F;O。eg. Ajax, fs.readFile 等，Node 中绝大数的操作都以异步的方式进行调用</li><li>事件与回调函数。将前端中广泛成熟点时间机制引入后端，配合 IO 使用，eg. 监听 request 事件，然后执行回调函数</li><li>单线程。保留了 JS 在浏览器中单线程的特点<ul><li>优点：不用在意状态的同步问题，没有死锁的存在，也没有上下文交互的性能开销</li><li>弱点：<ul><li>无法利用多核 CPU</li><li>错误会引起整个应用退出，代码健壮性值得考验</li><li>大量计算占用 CPU 无法继续调用异步 I&#x2F;O。eg. 长时间的 CPU 占用会导致后续的异步 IO 发不出调用。浏览器中类似的问题被 Web Worker 解决，Node 也采用类似的思路：子进程 child_process</li></ul></li><li>子进程的出现可以解决单线程在健壮性和无法利用多核 CPU 的问题。通过将计算分发到各个子进程，可以将大量斤算分解掉，再通过进程的事件消息来传递结果，可很好地保持应用模型的简单和依赖；通过 Master-Worker 的管理方式，也可以很好地管理各个工作的进程，以达到更高的健壮性</li></ul></li><li>跨平台。Node 基于 libuv 实现跨平台，可以在 Linux，Window 使用。它在操作系统和 Node 上层模块系统之间构建了一层平台层架构，即 libuv。libux 也是许多系统实现跨平台的基础组件</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>I&#x2F;O 密集</li><li>CPU 密集是否不合适？Node 没有提供多线程用于计算支持，但是仍有两个方式充分利用 CPU:<ul><li>Node 可以通过编写 C++扩展的方式提高 CPU 利用，将一些 V8 不能做到性能极致的地方用 C++来实现</li><li>用子进程的方式，将一部分进程用来计算，然后用进程通信传递结果，将计算和 I&#x2F;O 分离</li></ul></li></ul><h2 id="应用好处"><a href="#应用好处" class="headerlink" title="应用好处"></a>应用好处</h2><p>用 Node 做 Web 开发，前端工程师在 HTTP 协议栈的两端能高效灵活开发，避免了 Java 的繁琐；另一方面，又利用 Java 作为后端接口和中间件，使其有良好的稳定性。两者取长补短</p><h1 id="第二章-模块机制"><a href="#第二章-模块机制" class="headerlink" title="第二章 模块机制"></a>第二章 模块机制</h1><h2 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h2><p>解决 JS 弱结构性的问题，愿景：希望 JS 能在任何地方运行<br>eg.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(‘math’)</span><br><span class="line">…</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; xxx &#125;</span><br></pre></td></tr></table></figure><h2 id="Node-模块的实现"><a href="#Node-模块的实现" class="headerlink" title="Node 模块的实现"></a>Node 模块的实现</h2><h3 id="引入模块的实现步骤："><a href="#引入模块的实现步骤：" class="headerlink" title="引入模块的实现步骤："></a>引入模块的实现步骤：</h3><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><blockquote><p>Node 提供的模块称为核心模块；用户编写的模块称为文件模块。都会优先从缓存加载 Module._cache；缓存的是 Node 编译和执行后的对象</p></blockquote><h3 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h3><blockquote><p>核心模块部分在 Node 源代码的变异过程中，编译进了二进制执行文件；启动时就被直接加载进内存中；而文件模块是在运行时动态加载，需要完成走上述三个流程<br>定位到具体文件后，Node 会新建一个模块对象，然后根据路径载入并编译。对不同的文件扩展名，载入方式不同:</p></blockquote><ul><li>.js。通过 fs 模块读取文件后编译执行</li><li>.node。这是 C&#x2F;C++编写的扩展文件，通过 process.dlopen()方法加载最后编译生成的文件(但其实 C&#x2F;C++模块不用编译，它本来就是编译好的)。C&#x2F;C++模块的优势是执行效率；但显然 JS 编写的模块开发速度更快</li><li>.json。fs 模块读取后，用 JSON.parse()解析返回结果</li><li>其他。都被当成.js</li></ul><h2 id="核心模块-编译-编写核心模块"><a href="#核心模块-编译-编写核心模块" class="headerlink" title="核心模块 &amp; 编译 &amp; 编写核心模块"></a>核心模块 &amp; 编译 &amp; 编写核心模块</h2><p>核心模块分为 C&#x2F;C++编写的和 JS 编写的两部分。Node 的 buffer，crypto，evals，fs，os 等模块都是部分通过 C&#x2F;C++编写的</p><h2 id="C-C-扩展模块-加载-编写"><a href="#C-C-扩展模块-加载-编写" class="headerlink" title="C&#x2F;C++扩展模块 &amp; 加载 &amp; 编写"></a>C&#x2F;C++扩展模块 &amp; 加载 &amp; 编写</h2><p>CPU 性能更加</p><h2 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h2><p><img src="/img/Node/%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E6%A0%88.png"></p><h2 id="包和-NPM"><a href="#包和-NPM" class="headerlink" title="包和 NPM"></a>包和 NPM</h2><p>在模块之外，包和 NPM 是将模块联系起来的一种机制，是在模块的基础上进一步组织 JS 代码。包结构如下：</p><ul><li>package.json</li><li>bin。存放可执行的二进制文件</li><li>lib。存放 JS 代码</li><li>doc</li><li>test。单元测试用例</li></ul><h2 id="已经很少用的-AMD-和-CMD-规范"><a href="#已经很少用的-AMD-和-CMD-规范" class="headerlink" title="已经很少用的 AMD 和 CMD 规范"></a>已经很少用的 AMD 和 CMD 规范</h2><h1 id="第三章-异步-I-O"><a href="#第三章-异步-I-O" class="headerlink" title="第三章 异步 I&#x2F;O"></a>第三章 异步 I&#x2F;O</h1><h2 id="异步-I-O-实现现状"><a href="#异步-I-O-实现现状" class="headerlink" title="异步 I&#x2F;O 实现现状"></a>异步 I&#x2F;O 实现现状</h2><p>阻塞 IO 造成 CPU 等待浪费，非阻塞带来的麻烦事需要轮训去确认是否完成数据获取，它会让 CPU 处理状态判断，是对 CPU 资源的浪费<br>轮询的五种方案：read, select,poll, epoll(效率最高), kqueue。见 P53</p><h2 id="Node-的异步-IO"><a href="#Node-的异步-IO" class="headerlink" title="Node 的异步 IO"></a>Node 的异步 IO</h2><blockquote><p>事件循环、观察者、请求对象、I&#x2F;O 线程池这四者共同构建成了 Node 异步 I&#x2F;O 模型的基本要素<br>事件循环是异步实现的核心</p></blockquote><ul><li>Node 自身的执行模型是<strong>事件循环</strong>，正是它使得回调函数十分普遍。进程启动的时候，Node 会创建一个类似 whlie 的循环，每执行一次循环体的过程我们称为 Tick。如下图</li><li>(还有事件?) 那里即是<strong>观察者</strong></li></ul><p><img src="/img/Node/Tick.png"></p><h3 id="请求对象-和-I-O-线程池"><a href="#请求对象-和-I-O-线程池" class="headerlink" title="请求对象 和 I&#x2F;O 线程池"></a>请求对象 和 I&#x2F;O 线程池</h3><p>没太看懂。反正整个异步 IO 流程如下：</p><blockquote><p>输入输出完成端口（Input&#x2F;Output Completion Port，IOCP）</p></blockquote><p><img src="/img/Node/%E5%BC%82%E6%AD%A5IO%E6%B5%81%E7%A8%8B.png"></p><ul><li>这里的单线程与 IO 线程池看起来有些悖论的杨祖。由于我们知道 JS 是单线程的，所以按常识容易理解为它不能充分利用多核 CPU。事实上，在 Node 中，除了 JS 是单线程外，Node 自身其实是多线程的，只是 IO 线程使用的 CPU 较少</li><li>另一点需要重视的观点则是，除了用户代码无法并行执行外，所有的 IO（磁盘 IO 和网络 IO 等）则是可以并行起来的</li></ul><h2 id="非-IO-的异步-API"><a href="#非-IO-的异步-API" class="headerlink" title="非 IO 的异步 API"></a>非 IO 的异步 API</h2><blockquote><p>Node 中与 IO 无关的异步 API：setTimeout(), setInterval(), setImmediate(), process.nextTick()</p></blockquote><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>setTimeout()和 setInterval()和浏览器中是一致的，分别用于单次和多次定时执行任务。</p><ul><li>原理。它们的原理与异步 IO 比较类似，只是不需要 IO 线程池的参与。调用 setTimeout()或 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代去除定时器对象，检查是否超过时间，如果超过，就形成一个事件，它的回调函数将立即执行。这个过程包含动用红黑树，创建定时器对象和迭代等操作，较为浪费性能</li><li>问题。它并非精准的。尽管时间循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。eg. 通过 setTimeout 设定一个任务在 10ms 后执行，但是在 9ms 后，有一个任务占用了 5ms 的 CPU 时间片，再次轮到定时器执行时，时间就已经过期 4ms 了</li></ul><p><img src="/img/Node/settimeout.png"></p><h3 id="process-nextTick-和-setImmediate"><a href="#process-nextTick-和-setImmediate" class="headerlink" title="process.nextTick() 和 setImmediate()"></a>process.nextTick() 和 setImmediate()</h3><ul><li>每次调用 process.nextTick 函数，只会将回调函数放入队列中，在下一轮 Tick 的时候取出运行。定时器中采用红黑树操作的时间复杂度为 O(lg(n)), 而 nextTick 为 O(1)，更为高效</li><li>setImmediate()和 process.nextTick 十分类似，都是将回调函数延迟执行。但是执行优先级没 process.nextTick 高。似乎都属于微任务？</li></ul><h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p><img src="/img/Node/web%E6%9C%8D%E5%8A%A1%E5%99%A8.png"><br>图3-15 利用Node构建Wen服务器的流程图</p><h1 id="第四章-异步编程"><a href="#第四章-异步编程" class="headerlink" title="第四章 异步编程"></a>第四章 异步编程</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li>高阶函数：可以把函数作为参数，或是将函数作为返回值的函数。eg. JS中的forEach, some, reduce等</li><li>偏函数：指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。个人理解：偏函数会返返回一个函数，返回的函数的一部分是由偏函数的参数生成的。eg. 封装一个判断类型的函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isType = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object &#x27;</span> + type + <span class="string">&#x27;]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Let</span> isString = <span class="title function_">isType</span>(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="title function_">isString</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="异步编程的优势和难点"><a href="#异步编程的优势和难点" class="headerlink" title="异步编程的优势和难点"></a>异步编程的优势和难点</h2><ul><li>优势：基于时间驱动的非阻塞IO模型</li><li>难点<ul><li>异常处理</li><li>函数嵌套太深</li><li>阻塞代码</li><li>多线程的编程。有了child_process</li><li>异步转同步</li></ul></li></ul><h2 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h2><h1 id="第五章-【重点】内存控制"><a href="#第五章-【重点】内存控制" class="headerlink" title="第五章 【重点】内存控制"></a>第五章 【重点】内存控制</h1><h2 id="【重点】V8的垃圾回收机制与内存限制"><a href="#【重点】V8的垃圾回收机制与内存限制" class="headerlink" title="【重点】V8的垃圾回收机制与内存限制"></a>【重点】V8的垃圾回收机制与内存限制</h2><h1 id="第六章-理解Buffer"><a href="#第六章-理解Buffer" class="headerlink" title="第六章 理解Buffer"></a>第六章 理解Buffer</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;感受：这本书更偏向于讲 NodeJS 的大纲和原理。所以本笔记只讲原理和case，对于API不熟的请翻&lt;a href=&quot;http://nodejs.cn/api/&quot;&gt;文档&lt;/a&gt;，或看&lt;a href=&quot;https://github.com/chyingp/nodejs-le</summary>
      
    
    
    
    <category term="后端" scheme="http://jacleklm.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Nodejs" scheme="http://jacleklm.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>按需加载 &amp; 样式自动加载 —— babel-plugin-import</title>
    <link href="http://jacleklm.github.io/2020/06/27/babel-plugin-import/"/>
    <id>http://jacleklm.github.io/2020/06/27/babel-plugin-import/</id>
    <published>2020-06-27T15:49:21.000Z</published>
    <updated>2023-09-17T14:00:22.873Z</updated>
    
    <content type="html"><![CDATA[<p>几乎完全转自 <a href="https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg">一篇文章搞定 babel-plugin-import 插件</a> ，可以理解为 读后 &amp; 自己敲一遍 的笔记，建议直接读原文章</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>我们用 element-ui 或 antd 的时候，样式都支持全局引入和按需引入。按需引入需要安装一个 <a href="https://github.com/ant-design/babel-plugin-import"><code>babel-plugin-import</code></a> 的插件，将全局的写法变成按需引入的写法。其实也是用了AST语法树转换的原理，实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">var</span> _button = <span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button/style&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;antd&quot;</span>,     <span class="comment">// 包名</span></span><br><span class="line">  <span class="string">&quot;libraryDirectory&quot;</span>: <span class="string">&quot;lib&quot;</span>, <span class="comment">// 目录，默认 lib</span></span><br><span class="line">  <span class="string">&quot;style&quot;</span>: <span class="literal">true</span>,             <span class="comment">// 是否引入 style</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它的看 <a href="https://github.com/ant-design/babel-plugin-import#usage">文档</a></p><h1 id="Working-mechanism"><a href="#Working-mechanism" class="headerlink" title="Working mechanism"></a>Working mechanism</h1><h2 id="What-does-babel-plugin-import-do"><a href="#What-does-babel-plugin-import-do" class="headerlink" title="What does babel-plugin-import do"></a>What does babel-plugin-import do</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当options为以下时候：</span></span><br><span class="line">&#123; <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;antd&quot;</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>);</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">var</span> _button = <span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button/style&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">_button</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">_button</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>以这段代码为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">AutoComplete</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><h3 id="第一步-依赖收集"><a href="#第一步-依赖收集" class="headerlink" title="第一步 依赖收集"></a>第一步 依赖收集</h3><p><code>babel-plubin-import</code> 会在 <code>ImportDeclaration</code> 里将所有的 <code>specifier</code> 收集起来，详见如下 ast<br><img src="/img/AST/antd.png"><br>可以从这个 ImportDeclaration 语句中提取几个关键点：</p><ul><li>source.value: antd</li><li>specifier.imported.name: Button</li><li>specifier.imported.name: AutoComplete</li></ul><p>PS: local.name 是导入进来的别名，比如 <code>import &#123; Button as MyButton &#125; from &#39;antd&#39;</code> 的 <code>MyButton</code> ; imported.name 是真实导入的变量名</p><p>所以要做的事：收集 依赖名 和 依赖来源。插件的代码可以实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ImportDeclaration</span>(path, state) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; node &#125; = path;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 代码里 import 的包名</span></span><br><span class="line">  <span class="keyword">const</span> &#123; value &#125; = node.<span class="property">source</span>;</span><br><span class="line">  <span class="comment">// 配在插件 options 的包名</span></span><br><span class="line">  <span class="keyword">const</span> &#123; libraryName &#125; = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// @babel/types 工具函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; types &#125; = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 内部状态</span></span><br><span class="line">  <span class="keyword">const</span> pluginState = <span class="variable language_">this</span>.<span class="title function_">getPluginState</span>(state);</span><br><span class="line">  <span class="comment">// 判断是不是需要使用该插件的包</span></span><br><span class="line">  <span class="keyword">if</span> (value === libraryName) &#123;</span><br><span class="line">    <span class="comment">// node.specifiers 表示 import 了什么</span></span><br><span class="line">    node.<span class="property">specifiers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">spec</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是不是 ImportSpecifier 类型的节点，也就是是否是大括号的</span></span><br><span class="line">      <span class="keyword">if</span> (types.<span class="title function_">isImportSpecifier</span>(spec)) &#123;</span><br><span class="line">        <span class="comment">// 收集依赖</span></span><br><span class="line">        <span class="comment">// 也就是 pluginState.specified.Button = Button</span></span><br><span class="line">        <span class="comment">// local.name 是导入进来的别名，比如 import &#123; Button as MyButton &#125; from &#x27;antd&#x27; 的 MyButton</span></span><br><span class="line">        <span class="comment">// imported.name 是真实导入的变量名</span></span><br><span class="line">        pluginState.<span class="property">specified</span>[spec.<span class="property">local</span>.<span class="property">name</span>] = spec.<span class="property">imported</span>.<span class="property">name</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// ImportDefaultSpecifier 和 ImportNamespaceSpecifier</span></span><br><span class="line">        pluginState.<span class="property">libraryObjs</span>[spec.<span class="property">local</span>.<span class="property">name</span>] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    pluginState.<span class="property">pathsToRemove</span>.<span class="title function_">push</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历了所有的 <code>ImportDeclaration</code> 类型的节点之后，就收集好了依赖关系，下一步就是如何加载它们了。</p><h3 id="第二步-判断是否使用"><a href="#第二步-判断是否使用" class="headerlink" title="第二步 判断是否使用"></a>第二步 判断是否使用</h3><p>判断import进来的组件是否有在后续代码中使用，即是下面代码中 <code>createElement</code> 的第一个参数，我们需要判断收集的依赖中是否有被 createElement 使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;Button&gt;Hello&lt;/Button&gt;);</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line">React.createElement(Button, null, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>所以我们可以看下 <code>React.createElement(Button, null, &quot;Hello&quot;)</code> 的AST<br><img src="/img/AST/create.png"><br>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CallExpression(path, state) &#123;</span><br><span class="line">  const &#123; node &#125; = path;</span><br><span class="line">  const file = (path &amp;&amp; path.hub &amp;&amp; path.hub.file) || (state &amp;&amp; state.file);</span><br><span class="line">  // 方法调用者的 name</span><br><span class="line">  const &#123; name &#125; = node.callee;</span><br><span class="line">  // babel-type 工具函数</span><br><span class="line">  const &#123; types &#125; = this;</span><br><span class="line">  // 内部状态</span><br><span class="line">  const pluginState = this.getPluginState(state);</span><br><span class="line"></span><br><span class="line">  // 如果方法调用者是 Identifier 类型</span><br><span class="line">  if (types.isIdentifier(node.callee)) &#123;</span><br><span class="line">    if (pluginState.specified[name]) &#123;</span><br><span class="line">      node.callee = this.importMethod(pluginState.specified[name], file, pluginState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 遍历 arguments 找我们要的 specifier</span><br><span class="line">  node.arguments = node.arguments.map(arg =&gt; &#123;</span><br><span class="line">    const &#123; name: argName &#125; = arg;</span><br><span class="line">    if (</span><br><span class="line">      pluginState.specified[argName] &amp;&amp;</span><br><span class="line">      path.scope.hasBinding(argName) &amp;&amp;</span><br><span class="line">      path.scope.getBinding(argName).path.type === &#x27;ImportSpecifier&#x27;</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 找到 specifier，调用 importMethod 方法</span><br><span class="line">      return this.importMethod(pluginState.specified[argName], file, pluginState);</span><br><span class="line">    &#125;</span><br><span class="line">    return arg;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>React.createElement(Button)</code> 之外，还有 <code>const btn = Button / [Button]</code> … 等多种情况会使用 Button，源码中都有对应的处理方法，感兴趣的可以自己<a href="https://github.com/ant-design/babel-plugin-import/blob/master/src/Plugin.js#L163-L272">看一下</a></p><h3 id="第三步-生成引入代码（核心）"><a href="#第三步-生成引入代码（核心）" class="headerlink" title="第三步 生成引入代码（核心）"></a>第三步 生成引入代码（核心）</h3><p>即删除原来的import，引入我们生成的import。创建import的时候会用到一个插件 @babel&#x2F;helper-module-imports。后续部分建议直接看原博客<a href="https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg">一篇文章搞定 babel-plugin-import 插件</a></p><h1 id="插件实现"><a href="#插件实现" class="headerlink" title="插件实现"></a>插件实现</h1><p>见原文章</p><p>Reference<br><a href="https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg">一篇文章搞定 babel-plugin-import 插件</a><br><a href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几乎完全转自 &lt;a href=&quot;https://mp.weixin.qq.com/s/KjkIud4-q0Nm-YBLG6D1zg&quot;&gt;一篇文章搞定 babel-plugin-import 插件&lt;/a&gt; ，可以理解为 读后 &amp;amp; 自己敲一遍 的笔记，建议直接读原文章&lt;/</summary>
      
    
    
    
    <category term="Engineering" scheme="http://jacleklm.github.io/categories/Engineering/"/>
    
    
    <category term="webpack" scheme="http://jacleklm.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>AST详解</title>
    <link href="http://jacleklm.github.io/2020/06/25/AST%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jacleklm.github.io/2020/06/25/AST%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-25T15:49:21.000Z</published>
    <updated>2023-09-17T14:00:22.858Z</updated>
    
    <content type="html"><![CDATA[<p>TODO：还有这篇 <a href="https://mp.weixin.qq.com/s/lWj1_rPm75dXROKEMf-eQg">字节分享</a><br>几乎完全转自 <a href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a> ，可以理解为 读后 &amp; 自己敲一遍 的笔记</p><h1 id="What-Why"><a href="#What-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h1><ul><li>What: 抽象语法树（Abstract Syntax Tree，简称 AST）是<strong>源代码的抽象语法结构的树状表现形式</strong></li><li>Why:<ul><li>webpack、eslint 等很多工具库的核心都是通过抽象语法树来实现对代码的检查、分析等操作</li><li>浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作，所以将 js 转化为抽象语法树更利于程序的分析</li></ul></li><li>一个简单的例子:<br><img src="/img/AST/AST.png"><ul><li>首先<strong>一段</strong>代码转换成的抽象语法树是一个对象，该对象会有一个顶级的 type 属性 Program；第二个属性是 body 是一个数组</li><li>body 数组中存放的每一项都是一个对象，里面包含了所有的对于该语句的描述信息</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type: 描述该语句的类型  --&gt; 变量声明的语句</span><br><span class="line">kind: 变量声明的关键字  --&gt; var</span><br><span class="line">declaration: 声明内容的数组，里面每一项也是一个对象</span><br><span class="line">  type: 描述该语句的类型</span><br><span class="line">  id: 描述变量名称的对象</span><br><span class="line">      type: 定义</span><br><span class="line">      name: 变量的名字</span><br><span class="line">  init: 初始化变量值的对象</span><br><span class="line">      type: 类型</span><br><span class="line">      value: 值 &quot;is tree&quot; 不带引号</span><br><span class="line">      row:  &quot;\&quot;is tree&quot;\&quot; 带引号</span><br></pre></td></tr></table></figure><h1 id="词法分析和语法分析"><a href="#词法分析和语法分析" class="headerlink" title="词法分析和语法分析"></a>词法分析和语法分析</h1><p><code>JavaScript</code> 是<strong>解释型语言</strong>，一般通过 <code>词法分析 -&gt; 语法分析 -&gt; 语法树</code>，就可以开始解释执行了。从 code 分析成 AST ，我们可以在<a href="http://esprima.org/">这里</a>看到效果</p><ul><li>词法分析：也叫扫描 (scans)，是将字符流转换为记号流 (tokens)，它会读取我们的代码然后按照一定的规则合成一个个的标识 (scans: code &#x3D;&gt; tokens)<br>。当词法分析源代码的时候，它会一个一个字符的读取代码；当它遇到空格、操作符，或者特殊符号的时候，它会认为一个话已经完成了。比如说：var a &#x3D; 2 ，这段代码通常会被分解成 var、a、&#x3D;、2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Keyword&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;var&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Identifier&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Punctuator&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;=&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Numeric&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>语法分析：也称解析器，将词法分析出来的数组转换成树的形式，同时验证语法。语法如果有错的话，抛出语法错误 (analyze: tokens &#x3D;&gt; syntax)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>syntax &#x3D;&gt; tree</li></ul><h1 id="What-can-AST-do"><a href="#What-can-AST-do" class="headerlink" title="What can AST do"></a>What can AST do</h1><ul><li>语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等</li><li>代码混淆压缩</li><li>优化变更代码，改变代码结构等</li></ul><p>eg. 有个函数 <code>function a() &#123;&#125;</code> 我想把它变成 <code>function b() &#123;&#125;</code><br>eg. 在 webpack 中代码编译完成后 <code>require(&#39;a&#39;)</code> –&gt; <code>__webapck__require__(&quot;*/**/a.js&quot;)</code></p><h1 id="The-analysis-process-of-AST"><a href="#The-analysis-process-of-AST" class="headerlink" title="The analysis process of AST"></a>The analysis process of AST</h1><h2 id="How-to-analysis"><a href="#How-to-analysis" class="headerlink" title="How to analysis"></a>How to analysis</h2><p>先说结果：AST 是<strong>深度优先遍历</strong><br>比如说一段代码 <code>function getUser() &#123;&#125;</code>，我们把函数名字更改为 hello<br>推荐另一个常用的 AST 在线转换网站<a href="https://astexplorer.net/">ast explorer</a>；可以在网站看转换效果，也可以用下面的工具看效果</p><ul><li>工具 (这三个是操作 AST 的三个重要模块，也是实现 babel 的核心依赖)<ul><li>esprima：code &#x3D;&gt; ast</li><li>estraverse: traverse ast</li><li>escodegen: ast &#x3D;&gt; code</li></ul></li><li>实例代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">&#x27;esprima&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">&#x27;estraverse&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function getUser() &#123;&#125;`</span></span><br><span class="line"><span class="comment">// 生成 AST</span></span><br><span class="line"><span class="keyword">const</span> ast = esprima.<span class="title function_">parseScript</span>(code)</span><br><span class="line"><span class="comment">// 转换 AST，只会遍历 type 属性</span></span><br><span class="line"><span class="comment">// traverse 方法中有进入和离开两个钩子函数</span></span><br><span class="line">estraverse.<span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title function_">enter</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enter -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">leave</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;leave -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>打印结果<br><img src="/img/AST/output.png"></li><li>所以是深度优先遍历<br><img src="/img/AST/tree.png"></li></ul><h2 id="Demo-修改函数名字"><a href="#Demo-修改函数名字" class="headerlink" title="Demo: 修改函数名字"></a>Demo: 修改函数名字</h2><p>此时我们发现函数的名字在 <code>type</code> 为 <code>Identifier</code> 的时候就是该函数的名字，我们就可以直接修改它便可实现一个更改函数名字的 AST 工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换树</span></span><br><span class="line">estraverse.<span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="comment">// 进入离开修改都是可以的</span></span><br><span class="line">  <span class="title function_">enter</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;enter -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="string">&#x27;Identifier&#x27;</span>) &#123;</span><br><span class="line">      node.<span class="property">name</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">leave</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;leave -&gt; node.type&#x27;</span>, node.<span class="property">type</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 生成新的代码</span></span><br><span class="line"><span class="keyword">const</span> result = escodegen.<span class="title function_">generate</span>(ast)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// function hello() &#123;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Application-of-AST"><a href="#Application-of-AST" class="headerlink" title="Application of AST"></a>Application of AST</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><h3 id="The-working-mechanism-of-babel"><a href="#The-working-mechanism-of-babel" class="headerlink" title="The working mechanism of babel"></a>The working mechanism of babel</h3><blockquote><p>babel 的主要作用就是 Es6 代码转换为 Es5 的代码，以兼容所有浏览器，主要原理就是运用了 AST。有个 class 语法转为 ES5 语法的 demo，见博客 <a href="https://segmentfault.com/a/1190000016706589?utm_medium=referral&utm_source=tuicool">AST 抽象语法树</a></p></blockquote><p>babel两个工具包重要的包： <code>@babel/core</code> (打通webpack和babel的一个通道)、<code>@babel/preset-env</code> (翻译器) (还有一个@babel&#x2F;polyfill（添加ES6中的新函数新变量，eg. Promise和map）)。当我们配置 babel 的时候，不管是在 <code>.babelrc</code> 或者 <code>babel.config.js</code> 文件里面配置的都有 presets 和 plugins 两个配置项</p><h4 id="presets和plugins的区别"><a href="#presets和plugins的区别" class="headerlink" title="presets和plugins的区别"></a>presets和plugins的区别</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们配置了 presets 中有 <code>@babel/preset-env</code>，那么 <code>@babel/core</code> 就会去找 <code>preset-env</code> 预设的插件包，它是一套预设好的插件配置。</p><p><code>@babel/core</code>并不会去转换代码，只提供一些核心 API，真正的代码转换工作由插件或者预设来完成，比如要转换箭头函数，会用到这个 plugin：<code>@babel/plugin-transform-arrow-functions</code>，当需要转换的要求增加时，我们不可能去一一配置相应的 plugin，这个时候就可以用到预设了，也就是 presets。<strong>presets 是 plugins 的集合</strong>，一个 presets 内部包含了很多 plugin</p><h4 id="babel中转换代码一个demo"><a href="#babel中转换代码一个demo" class="headerlink" title="babel中转换代码一个demo"></a>babel中转换代码一个demo</h4><p>现在我们有一个箭头函数，要想把它转成普通函数，我们就可以直接这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const fn = (a, b) =&gt; a + b`</span></span><br><span class="line"><span class="comment">// babel 有 transform 方法会帮我们自动遍历，使用相应的预设或者插件转换相应的代码</span></span><br><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">code</span>)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line"><span class="comment">// &quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">// var fn = function fn() &#123; return a + b; &#125;;</span></span><br></pre></td></tr></table></figure><p>此时我们可以看到最终代码会被转成普通函数，但是我们，只需要箭头函数转通函数的功能，不需要用这么大一套包，只需要一个箭头函数转普通函数的包，我们其实是可以在 <code>node_modules</code> 下面找到有个叫做 <code>plugin-transform-arrow-functions</code> 的插件，这个插件是专门用来处理 箭头函数的，我们就可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@babel/plugin-transform-arrow-functions&#x27;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">code</span>)</span><br><span class="line"><span class="comment">// 打印结果如下</span></span><br><span class="line"><span class="comment">// const fn = function () &#123; return a + b; &#125;;</span></span><br></pre></td></tr></table></figure><p>我们可以从打印结果发现此时并没有转换我们变量的声明方式还是 const 声明，只是转换了箭头函数</p><h3 id="编写一个箭头函数转普通函数的babel插件"><a href="#编写一个箭头函数转普通函数的babel插件" class="headerlink" title="编写一个箭头函数转普通函数的babel插件"></a>编写一个箭头函数转普通函数的babel插件</h3><p>首先应该看 <a href="https://juejin.im/post/5b14257ef265da6e5546b14b">Babel插件开发入门指南</a><br>现在我们来个实战把 <code>const fn = (a, b) =&gt; a + b</code> 转换为 <code>const fn = function(a, b) &#123; return a + b &#125;</code></p><h4 id="分析-AST-结构"><a href="#分析-AST-结构" class="headerlink" title="分析 AST 结构"></a>分析 AST 结构</h4><p>首先我们在在线分析 AST 的网站上分析 <code>const fn = (a, b) =&gt; a + b</code> 和 <code>const fn = function(a, b) &#123; return a + b &#125;</code> 看两者语法树的区别<br><img src="/img/AST/code.png"></p><p>分析可得：</p><ul><li>变成普通函数之后他就不叫箭头函数了 <code>ArrowFunctionExpression</code>，而是函数表达式了 <code>FunctionExpression</code></li><li>所以首先我们要把 箭头函数表达式(<code>ArrowFunctionExpression</code>) 转换为 函数表达式(<code>FunctionExpression</code>)</li><li>要把 二进制表达式(<code>BinaryExpression</code>) 放到一个 代码块中(<code>BlockStatement</code>)的 <code>ExpressionStatement</code>&#x2F; <code>ReturnStatement</code> 中。</li><li>其实我们要做就是把一棵树变成另外一颗树，说白了其实就是拼成另一颗树的结构，然后生成新的代码，就可以完成代码的转换</li></ul><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>在 babel 中，我们开发 plugins 的时候要用到<strong>访问者模式</strong>，就是说在访问到某一个路径的时候进行匹配，然后在对这个节点进行修改。<strong>这里的节点指的是AST树中的节点</strong>，比如下面是访问到 ArrowFunctionExpression 节点就执行下面的 ArrowFunctionExpression() 函数</p><p>那么我们就可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const fn = (a, b) =&gt; a + b`</span> <span class="comment">// 转换后 const fn = function(a, b) &#123; return a + b &#125;</span></span><br><span class="line"><span class="keyword">const</span> arrowFnPlugin = &#123;</span><br><span class="line">  <span class="comment">// 访问者模式</span></span><br><span class="line">  <span class="attr">visitor</span>: &#123;</span><br><span class="line">    <span class="comment">// 当访问到某个路径的时候进行匹配，比如下面是访问到 ArrowFunctionExpression 就执行下面的 ArrowFunctionExpression() 函数</span></span><br><span class="line">    <span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">      <span class="comment">// 拿到节点</span></span><br><span class="line">      <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ArrowFunctionExpression -&gt; node&#x27;</span>, node)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [arrowFnPlugin],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br></pre></td></tr></table></figure><h4 id="修改-AST-结构"><a href="#修改-AST-结构" class="headerlink" title="修改 AST 结构"></a>修改 AST 结构</h4><p>此时我们拿到的结果是这样的节点结果是 <a href="https://chengyuming.cn/json/arrowFn.json">这样的</a>，其实就是 <code>ArrowFunctionExpression</code> 的 AST，此时我们要做的是把 <code>ArrowFunctionExpression</code> 的结构替换成 <code>FunctionExpression的结构</code>。但要我们自己手写替换得毫无差错是很麻烦的，所以 babel 为我们提供了一个神仙工具叫做 <a href="https://babeljs.io/docs/en/babel-types"><code>@babel/types</code></a> <a href="https://www.babeljs.cn/docs/babel-types">中文版</a></p><p><code>@babel/types</code> 有两个作用：</p><ul><li>判断当前节点是不是某种特定节点（eg. 相当于之前的 node.type &#x3D;&#x3D;&#x3D; ‘ArrowFunctionExpression’ ）</li><li>生成对应的表达式</li></ul><p>那么接下来我们就开始生成一个 FunctionExpression，然后把之前的 <code>ArrowFunctionExpression</code> 替换掉，我们可以看 <code>@babel/types</code> 文档，找到 functionExpression 方法，该方法接受相应的参数我们传递过去即可生成一个 <code>FunctionExpression</code></p><blockquote><p>t.functionExpression(id, params, body, generator, async)</p></blockquote><ul><li>id: Identifier (default: null) id 可传递 null</li><li>params: Array<LVal> (required) 函数参数，可以把之前的参数拿过来</li><li>body: BlockStatement (required) 函数体，接受一个 BlockStatement 我们需要生成一个</li><li>generator: boolean (default: false) 是否为 generator 函数，当然不是了</li><li>async: boolean (default: false) 是否为 async 函数，肯定不是了</li></ul><p>还需要生成一个 <code>BlockStatement</code>，我们接着看文档找到 <code>BlockStatement</code> 接受的参数</p><blockquote><p>t.blockStatement(body, directives)</p></blockquote><p>看文档说明，blockStatement 接受一个 body，那我们把之前的 body 拿过来就可以直接用，不过这里 body 接受一个数组</p><p>我们细看 AST 结构，函数表达式中的 <code>BlockStatement</code> 中的 body 是一个 <code>ReturnStatement</code>，所以我们还需要生成一个 <code>ReturnStatement</code></p><p>现在我们就可以改写 AST 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const fn = (a, b) =&gt; a + b`</span> <span class="comment">// const fn = function(a, b) &#123; return a + b &#125;</span></span><br><span class="line"><span class="keyword">const</span> arrowFnPlugin = &#123;</span><br><span class="line">  <span class="comment">// 访问者模式</span></span><br><span class="line">  <span class="attr">visitor</span>: &#123;</span><br><span class="line">    <span class="comment">// 当访问到某个路径的时候进行匹配</span></span><br><span class="line">    <span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">      <span class="comment">// 拿到节点然后替换节点</span></span><br><span class="line">      <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ArrowFunctionExpression -&gt; node&#x27;</span>, node)</span><br><span class="line">      <span class="comment">// 拿到函数的参数</span></span><br><span class="line">      <span class="keyword">const</span> params = node.<span class="property">params</span></span><br><span class="line">      <span class="keyword">const</span> body = node.<span class="property">body</span></span><br><span class="line">      <span class="keyword">const</span> functionExpression = t.<span class="title function_">functionExpression</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        params,</span><br><span class="line">        t.<span class="title function_">blockStatement</span>([body])</span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 替换原来的函数</span></span><br><span class="line">      path.<span class="title function_">replaceWith</span>(functionExpression)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> r = babel.<span class="title function_">transform</span>(code, &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [arrowFnPlugin],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r.<span class="property">code</span>) <span class="comment">// const fn = function (a, b) &#123; return a + b; &#125;;</span></span><br></pre></td></tr></table></figure><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>我们知道在剪头函数中是可以省略 return 关键字，我们上面是处理了省略关键字的写法，但是如果用户写了 return 关键字后，我们写的这个插件就有问题了，所以我们可以在优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">a, b</span>) =&gt; &#123; retrun a + b &#125; -&gt; <span class="keyword">const</span> fn = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a + b &#125;</span><br></pre></td></tr></table></figure><p>观察代码我们发现，我们就不需要把 body 转换成 <code>blockStatement</code> 了，直接放过去就可以了，那么我们就可以这么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">  <span class="comment">// 拿到节点然后替换节点</span></span><br><span class="line">  <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ArrowFunctionExpression -&gt; node&quot;</span>, node)</span><br><span class="line">  <span class="comment">// 拿到函数的参数</span></span><br><span class="line">  <span class="keyword">const</span> params = node.<span class="property">params</span></span><br><span class="line">  <span class="keyword">let</span> body = node.<span class="property">body</span></span><br><span class="line">  <span class="comment">// 判断是不是 blockStatement，不是的话让他变成 blockStatement</span></span><br><span class="line">  <span class="keyword">if</span> (!t.<span class="title function_">isBlockStatement</span>(body)) &#123;</span><br><span class="line">    body = t.<span class="title function_">blockStatement</span>([body])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> functionExpression = t.<span class="title function_">functionExpression</span>(<span class="literal">null</span>, params, body)</span><br><span class="line">  <span class="comment">// 替换原来的函数</span></span><br><span class="line">  path.<span class="title function_">replaceWith</span>(functionExpression)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写一个claas转ES5的babel插件"><a href="#编写一个claas转ES5的babel插件" class="headerlink" title="编写一个claas转ES5的babel插件"></a>编写一个claas转ES5的babel插件</h3><p>见 <a href="https://segmentfault.com/a/1190000016706589?utm_medium=referral&utm_source=tuicool">AST 抽象语法树</a><br>类似的实际插件是 <code>@babel/plugin-transform-classes</code></p><h2 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h2><p>我们用 element-ui 或 antd 的时候，样式都支持全局引入和按需引入。按需引入需要安装一个 <code>babel-plugin-import</code> 的插件，将全局的写法变成按需引入的写法。其实也是用了AST语法树转换的原理，实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">      ↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="keyword">var</span> _button = <span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;antd/lib/button/style&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(这个插件详见另一篇博客 <a href="https://jacleklm.github.io/2020/06/27/babel-plugin-import/">按需加载 &amp; 样式自动加载 —— babel-plugin-import</a>)</p><h2 id="babylon"><a href="#babylon" class="headerlink" title="babylon"></a>babylon</h2><blockquote><p>在 babel 官网上有一句话 <a href="https://babeljs.io/docs/en/babylon">Babylon</a> is a JavaScript parser used in Babel。（即是Babel 的解析引擎）</p></blockquote><h3 id="babel-与-babylon-的关系"><a href="#babel-与-babylon-的关系" class="headerlink" title="babel 与 babylon 的关系"></a>babel 与 babylon 的关系</h3><p>from <a href="http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/">alloyteam-剖析babel</a> ：<br>Babel 使用的引擎是 babylon，babylon 并非由 babel 团队自己开发的，而是 fork 的 acorn 项目，acorn 的项目本人在很早之前在兴趣部落 1.0 在构建中使用，为了是做一些代码的转换，是很不错的一款引擎，不过 acorn 引擎只提供基本的解析 ast 的能力，遍历还需要配套的 acorn-travesal, 替换节点需要使用 acorn-，而这些开发，在 Babel 的插件体系开发下，变得一体化了 </p><h3 id="使用-babylon-编写一个数组扩展运算符-转-Es5-语法的插件"><a href="#使用-babylon-编写一个数组扩展运算符-转-Es5-语法的插件" class="headerlink" title="使用 babylon 编写一个数组扩展运算符 转 Es5 语法的插件"></a>使用 babylon 编写一个数组扩展运算符 转 Es5 语法的插件</h3><p>把 <code>const arr = [ ...arr1, ...arr2 ]</code> 转成 <code>var arr = [].concat(arr1, arr2)</code></p><p>我们使用 babylon 的话就不需要使用 <code>@babel/core</code> 了，只需要用到他里面的 <code>traverse</code> 和 <code>generator</code>，用到的包有 <code>babylon</code>、<code>@babel/traverse</code>、<code>@babel/generator</code>、<code>@babel/types</code></p><h3 id="分析语法树"><a href="#分析语法树" class="headerlink" title="分析语法树"></a>分析语法树</h3><p>看一下两棵语法树的区别<br><img src="/img/AST/bablon.png"><br>根据上图我们分析得出：</p><ul><li>两棵树都是变量声明的方式，不同的是他们声明的关键字不一样</li><li>他们初始化变量值的时候是不一样的，一个数组表达式（ArrayExpression）另一个是调用表达式（CallExpression）</li><li>那我们要做的就很简单了，就是把 数组表达式转换为调用表达式就可以</li></ul><h3 id="分析类型"><a href="#分析类型" class="headerlink" title="分析类型"></a>分析类型</h3><p>这段代码的核心生成一个 callExpression 调用表达式，所以对应官网上的类型，我们分析需要用到的 api</p><ul><li>先来分析 init 里面的，首先是 callExpression<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; callee  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Expression | SpreadElement | JSXNamespacedName&gt;</span>&#125; source (required)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">callExpression</span>(callee, <span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure></li><li>对应语法树上 callee 是一个 MemberExpression，所以要生成一个成员表达式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; object  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">if computed then Expression else Identifier</span>&#125; property (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; computed (default: false)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; optional (default: null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">memberExpression</span>(object, property, computed, optional)</span><br></pre></td></tr></table></figure></li><li>在 callee 的 object 是一个 ArrayExpression 数组表达式，是一个空数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;null | Expression | SpreadElement&gt;</span>&#125; elements  (default: [])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">arrayExpression</span>(elements)</span><br></pre></td></tr></table></figure></li><li>对了里面的东西分析完了，我们还要生成 VariableDeclarator 和 VariableDeclaration 最终生成新的语法树<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">LVal</span>&#125; id  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; init (default: null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">variableDeclarator</span>(id, init)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">&quot;var&quot; | &quot;let&quot; | &quot;const&quot;</span>&#125; kind  (required)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;VariableDeclarator&gt;</span>&#125; declarations (required)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t.<span class="title function_">variableDeclaration</span>(kind, declarations)</span><br></pre></td></tr></table></figure>其实倒着分析语法树，分析完怎么写也就清晰了，那么我们开始上代码吧</li></ul><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">&#x27;babylon&#x27;</span>)</span><br><span class="line"><span class="comment">// 使用 babel 提供的包，traverse 和 generator 都是被暴露在 default 对象上的</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).<span class="property">default</span></span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const arr = [ ...arr1, ...arr2 ]`</span> <span class="comment">// var arr = [].concat(arr1, arr2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = babylon.<span class="title function_">parse</span>(code, &#123;</span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换树</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">VariableDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = path.<span class="property">node</span></span><br><span class="line">    <span class="keyword">const</span> declarations = node.<span class="property">declarations</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;VariableDeclarator -&gt; declarations&#x27;</span>, declarations)</span><br><span class="line">    <span class="keyword">const</span> kind = <span class="string">&#x27;var&#x27;</span></span><br><span class="line">    <span class="comment">// 边界判定</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">kind</span> !== kind &amp;&amp; declarations.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; t.<span class="title function_">isArrayExpression</span>(declarations[<span class="number">0</span>].<span class="property">init</span>)) &#123;</span><br><span class="line">      <span class="comment">// 取得之前的 elements</span></span><br><span class="line">      <span class="keyword">const</span> args = declarations[<span class="number">0</span>].<span class="property">init</span>.<span class="property">elements</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">argument</span>)</span><br><span class="line">      <span class="keyword">const</span> callee = t.<span class="title function_">memberExpression</span>(t.<span class="title function_">arrayExpression</span>(), t.<span class="title function_">identifier</span>(<span class="string">&#x27;concat&#x27;</span>), <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">const</span> init = t.<span class="title function_">callExpression</span>(callee, args)</span><br><span class="line">      <span class="keyword">const</span> declaration = t.<span class="title function_">variableDeclarator</span>(declarations[<span class="number">0</span>].<span class="property">id</span>, init)</span><br><span class="line">      <span class="keyword">const</span> variableDeclaration = t.<span class="title function_">variableDeclaration</span>(kind, [declaration])</span><br><span class="line">      path.<span class="title function_">replaceWith</span>(variableDeclaration)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="具体语法书"><a href="#具体语法书" class="headerlink" title="具体语法书"></a>具体语法书</h1><p>和抽象语法树相对的是具体语法树（Concrete Syntax Tree）简称 CST（通常称作分析树）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。可参考抽象语法树和具体语法树有什么区别？</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>关于 node 类型，全集大致如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(parameter) <span class="attr">node</span>: <span class="title class_">Identifier</span> | <span class="title class_">SimpleLiteral</span> | <span class="title class_">RegExpLiteral</span> | <span class="title class_">Program</span> | <span class="title class_">FunctionDeclaration</span> | <span class="title class_">FunctionExpression</span> | </span><br><span class="line"><span class="title class_">ArrowFunctionExpression</span> | <span class="title class_">SwitchCase</span> | <span class="title class_">CatchClause</span> | <span class="title class_">VariableDeclarator</span> | <span class="title class_">ExpressionStatement</span> | <span class="title class_">BlockStatement</span> | </span><br><span class="line"><span class="title class_">EmptyStatement</span> | <span class="title class_">DebuggerStatement</span> | <span class="title class_">WithStatement</span> | <span class="title class_">ReturnStatement</span> | <span class="title class_">LabeledStatement</span> | <span class="title class_">BreakStatement</span> | </span><br><span class="line"><span class="title class_">ContinueStatement</span> | <span class="title class_">IfStatement</span> | <span class="title class_">SwitchStatement</span> | <span class="title class_">ThrowStatement</span> | <span class="title class_">TryStatement</span> | <span class="title class_">WhileStatement</span> | <span class="title class_">DoWhileStatement</span> | </span><br><span class="line"><span class="title class_">ForStatement</span> | <span class="title class_">ForInStatement</span> | <span class="title class_">ForOfStatement</span> | <span class="title class_">VariableDeclaration</span> | <span class="title class_">ClassDeclaration</span> | <span class="title class_">ThisExpression</span> | </span><br><span class="line"><span class="title class_">ArrayExpression</span> | <span class="title class_">ObjectExpression</span> | <span class="title class_">YieldExpression</span> | <span class="title class_">UnaryExpression</span> | <span class="title class_">UpdateExpression</span> | <span class="title class_">BinaryExpression</span> | </span><br><span class="line"><span class="title class_">AssignmentExpression</span> | <span class="title class_">LogicalExpression</span> | <span class="title class_">MemberExpression</span> | <span class="title class_">ConditionalExpression</span> | <span class="title class_">SimpleCallExpression</span> | </span><br><span class="line"><span class="title class_">NewExpression</span> | <span class="title class_">SequenceExpression</span> | <span class="title class_">TemplateLiteral</span> | <span class="title class_">TaggedTemplateExpression</span> | <span class="title class_">ClassExpression</span> | <span class="title class_">MetaProperty</span> | </span><br><span class="line"><span class="title class_">AwaitExpression</span> | <span class="title class_">Property</span> | <span class="title class_">AssignmentProperty</span> | <span class="title class_">Super</span> | <span class="title class_">TemplateElement</span> | <span class="title class_">SpreadElement</span> | <span class="title class_">ObjectPattern</span> |</span><br><span class="line"> <span class="title class_">ArrayPattern</span> | <span class="title class_">RestElement</span> | <span class="title class_">AssignmentPattern</span> | <span class="title class_">ClassBody</span> | <span class="title class_">MethodDefinition</span> | <span class="title class_">ImportDeclaration</span> | </span><br><span class="line"> <span class="title class_">ExportNamedDeclaration</span> | <span class="title class_">ExportDefaultDeclaration</span> | <span class="title class_">ExportAllDeclaration</span> | <span class="title class_">ImportSpecifier</span> | </span><br><span class="line"> <span class="title class_">ImportDefaultSpecifier</span> | <span class="title class_">ImportNamespaceSpecifier</span> | <span class="title class_">ExportSpecifier</span></span><br></pre></td></tr></table></figure><p>Babel 有文档对 AST 树的详细定义，可参考<a href="https://github.com/babel/babylon/blob/master/ast/spec.md">这里</a></p><p>参考资料<br><a href="https://juejin.im/post/5b14257ef265da6e5546b14b">Babel插件开发入门指南</a><br><a href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a><br><a href="http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/">alloyteam-剖析babel</a><br><a href="https://cheogo.github.io/learn-javascript/201709/runtime.html">JavaScript 语法解析、AST、V8、JIT</a><br><a href="https://blog.csdn.net/huangpb123/article/details/84799198">详解AST抽象语法树</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO：还有这篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/lWj1_rPm75dXROKEMf-eQg&quot;&gt;字节分享&lt;/a&gt;&lt;br&gt;几乎完全转自 &lt;a href=&quot;https://chengyuming.cn/views/webpack/AS</summary>
      
    
    
    
    <category term="Engineering" scheme="http://jacleklm.github.io/categories/Engineering/"/>
    
    
    <category term="webpack" scheme="http://jacleklm.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>渲染方案</title>
    <link href="http://jacleklm.github.io/2020/05/27/%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/"/>
    <id>http://jacleklm.github.io/2020/05/27/%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88/</id>
    <published>2020-05-27T08:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="长列表-无限下拉列表-渲染"><a href="#长列表-无限下拉列表-渲染" class="headerlink" title="长列表 &#x2F; 无限下拉列表 渲染"></a>长列表 &#x2F; 无限下拉列表 渲染</h1><p>考虑到性能，我们不可能将一个长列表（甚至是一个无限下拉列表）的所有列表元素都进行渲染，应该是只渲染部分数据并随着下拉渲染新数据</p><h2 id="方案一：Intersection-Observer-padding"><a href="#方案一：Intersection-Observer-padding" class="headerlink" title="方案一：Intersection Observer + padding"></a>方案一：Intersection Observer + padding</h2><p>该方案来自<a href="https://mp.weixin.qq.com/s/X2ltQyp3W0othLv_m6-Ydg">云音乐-一个简洁、有趣的无限下拉方案</a></p><h3 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h3><p>详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">MDN</a>，建议全都读完</p><p>一直以来，<strong>检测元素的可视状态或者两个元素的相对可视状态</strong>都不是件容易事。传统的各种方案不但复杂，而且性能成本很高，比如需要监听滚动事件，然后查询 DOM , 获取元素高度、位置，计算距离视窗高度等等。</p><p>这就是 Intersection Observer 要解决的问题。它为开发人员提供一种便捷的新方法来异步查询元素相对于其他元素或视窗的位置，消除了昂贵的 DOM 查询和样式读取成本</p><p>它不能告诉你的一件事情是 (两个元素的)重叠部分的准确像素个数或者重叠的像素属于哪一个元素。然而这个API覆盖最广的最常用的使用方式是 <strong>如果两个元素发生的交集部分在N%左右，我需要做处理一些事情(执行回调)</strong></p><blockquote><p>在 Safari 上兼容性较差，需要 12.2 及以上才兼容，否则需配合 polyfill  使用</p></blockquote><p>一些应用场景：</p><ul><li>当页面滚动时，懒加载图片或其他内容。</li><li>实现“可无限滚动”网站，也就是当用户滚动网页时直接加载更多内容，无需翻页。</li><li>为计算广告收益，检测其广告元素的曝光情况。</li><li>根据用户是否已滚动到相应区域来灵活开始执行任务或动画</li></ul><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><ol><li>创建一个 IntersectionObserver对象。</li></ol><ul><li>root必须是目标元素的父级元素；如果未指定或者为null，则默认为浏览器视窗</li><li>rootMargin是root元素的外边距。类似于css中的 margin 属性</li><li>threshold。目标(target)元素与根(root)元素之间的交叉度是交叉比(intersection ratio)。这是目标(target)元素相对于根(root)的交集百分比的表示，它的取值在0.0和1.0之间。阈值为1.0意味着目标元素完全出现在root选项指定的元素中可见时，回调函数将会被执行。可以是单一的number也可以是number数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>), </span><br><span class="line">  <span class="attr">rootMargin</span>: <span class="string">&#x27;0px&#x27;</span>, </span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>每个观察者配置一个目标。每当目标满足该IntersectionObserver指定的threshold值，回调被调用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#listItem&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure></li><li>回调函数。回调接收 IntersectionObserverEntry对象和观察者的列表：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123; </span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 这里的 entry 是 IntersectionObserverEntry 对象，entry.target 是目标元素</span></span><br><span class="line">    <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">    <span class="comment">//   entry.isIntersecting</span></span><br><span class="line">    <span class="comment">//   entry.rootBounds</span></span><br><span class="line">    <span class="comment">//   entry.target</span></span><br><span class="line">    <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>entry的属性大概是这样：<br><img src="/img/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/entry.png"><br>详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry">MDN-IntersectionObserverEntry</a></li></ol><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>总体思路：利用 Intersection Observer 来监测相关元素的滚动位置，异步监听，尽可能得减少 DOM 操作，触发回调，然后去获取新的数据来更新页面元素，并且用调整容器 padding 来替代了本该越来越多的 DOM 元素，最终实现列表滚动、无限下拉。具体如下：</p><ol><li>监听一个固定长度列表的首尾元素是否进入视窗<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 观察者创建</span><br><span class="line">this.observer = new IntersectionObserver(callback, options);</span><br><span class="line"></span><br><span class="line">// 观察列表第一个以及最后一个元素</span><br><span class="line">this.observer.observe(this.firstItem);</span><br><span class="line">this.observer.observe(this.lastItem);</span><br><span class="line"></span><br><span class="line">const callback = (entries) =&gt; &#123;</span><br><span class="line">  entries.forEach((entry) =&gt; &#123;</span><br><span class="line">    if (entry.target.id === firstItemId) &#123;</span><br><span class="line">      // 当第一个元素进入视窗</span><br><span class="line">    &#125; else if (entry.target.id === lastItemId) &#123;</span><br><span class="line">      // 当最后一个元素进入视窗</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>更新当前页面内渲染的第一个元素对应的序号(firstIndex)。我们用一个数组来维护需要渲染到页面中的数据。数组的长度会随着不断请求新的数据而不断变大，而渲染的始终是其中一定数量的元素，比如 20 个。那么：</li></ol><ul><li>最开始渲染的是数组中序号为 0 - 19 的元素，即此时对应的 firstIndex 为 0；</li><li>当序号为 19 的元素（即上一步的 lastItem ）进入视窗时，我们就会往后渲染 10 个元素，即渲染序号为 10 - 29 的元素，那么此时的 firstIndex 为 10；</li><li>下一次就是，当序号为 29 的元素进入视窗时，继续往后渲染 10个元素，即渲染序号为 20 - 39 的元素，那么此时的 firstIndex 为 20，以此类推。。。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 我们对原先的 firstIndex 做了缓存</span><br><span class="line">const &#123; currentIndex &#125; = this.domDataCache;</span><br><span class="line"></span><br><span class="line">// 以全部容器内所有元素的一半作为每一次渲染的增量</span><br><span class="line">const increment = Math.floor(this.listSize / 2);</span><br><span class="line"></span><br><span class="line">let firstIndex;</span><br><span class="line"></span><br><span class="line">if (isScrollDown) &#123;</span><br><span class="line">  // 向下滚动时序号增加</span><br><span class="line">  firstIndex = currentIndex + increment;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 向上滚动时序号减少</span><br><span class="line">  firstIndex = currentIndex - increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>根据上述序号，获取目标数据元素，列表内容重新渲染成对应内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const renderFunction = (firstIndex) =&gt; &#123;</span><br><span class="line">  // offset = firstIndex, limit = 10 =&gt; getData</span><br><span class="line">  // getData Done =&gt;  new dataItems =&gt; render DOM</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li>容器 padding 调整，模拟滚动实现<br>其实不用这一步也可以，直接获取了 10 个新的数据元素之后，再塞 10 个新的 DOM 元素到页面中去来渲染这些数据。但是 DOM 会越来越多，页面DOM太多可能会有性能问题。所以这里的方案是：用原来已有的 DOM 元素去渲染，替换掉已经离开视窗、不可见的数据元素；而本该由更多 DOM 元素进一步撑开容器高度的部分，我们用 padding 填充来模拟实现。</li></ol><ul><li>向下滚动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// padding的增量 = 每一个item的高度 x 新的数据项的数目</span><br><span class="line">const remPaddingsVal = itemHeight * (Math.floor(this.listSize / 2));</span><br><span class="line"></span><br><span class="line">if (isScrollDown) &#123;</span><br><span class="line">  // paddingTop新增，填充顶部位置</span><br><span class="line">  newCurrentPaddingTop = currentPaddingTop + remPaddingsVal;</span><br><span class="line"></span><br><span class="line">  if (currentPaddingBottom === 0) &#123;</span><br><span class="line">    newCurrentPaddingBottom = 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果原来有paddingBottom则减去，会有滚动到底部的元素进行替代</span><br><span class="line">    newCurrentPaddingBottom = currentPaddingBottom - remPaddingsVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>向上滚动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// padding的增量 = 每一个item的高度 x 新的数据项的数目</span><br><span class="line">const remPaddingsVal = itemHeight * (Math.floor(this.listSize / 2));</span><br><span class="line"></span><br><span class="line">if (!isScrollDown) &#123;</span><br><span class="line">  // paddingBottom新增，填充底部位置</span><br><span class="line">  newCurrentPaddingBottom = currentPaddingBottom + remPaddingsVal;</span><br><span class="line"></span><br><span class="line">  if (currentPaddingTop === 0) &#123;</span><br><span class="line">    newCurrentPaddingTop = 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果原来有paddingTop则减去，会有滚动到顶部的元素进行替代</span><br><span class="line">    newCurrentPaddingTop = currentPaddingTop - remPaddingsVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最后是 padding 设置更新以及相关缓存数据更新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 容器padding重新设置</span><br><span class="line">this.updateContainerPadding(&#123;</span><br><span class="line">  newCurrentPaddingBottom,</span><br><span class="line">  newCurrentPaddingTop</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// DOM元素相关数据缓存更新</span><br><span class="line">this.updateDomDataCache(&#123;</span><br><span class="line">    currentPaddingTop: newCurrentPaddingTop,</span><br><span class="line">  currentPaddingBottom: newCurrentPaddingBottom</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>完整代码实现参考<a href="https://github.com/Guohjia/listScroll">https://github.com/Guohjia/listScroll</a></p></blockquote><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>padding 的计算依赖列表项固定的高度</li><li>这是一个同步渲染的方案，也就是目前容器 padding 的计算调整，无法计算异步获取的数据，只跟用户的滚动行为有关。解决思路：<ul><li>思路1：利用 Skeleton Screen Loading 来同步渲染数据元素，不受数据异步获取的影响。即在数据请求还未完成时，先使用一些图片进行占位，待内容加载完成之后再进行替换。</li><li>思路2：滚动到目标位置，阻塞容器 padding 的设置（即无限下拉的发生）直至数据请求完毕，用 loading gif 提示用户加载状态，但这个方案相对复杂，你需要全面考虑用户难以预测的滚动行为来设置容器的 padding。</li></ul></li></ul><h2 id="方案二：较为有名的库-iScroll"><a href="#方案二：较为有名的库-iScroll" class="headerlink" title="方案二：较为有名的库 - iScroll"></a>方案二：较为有名的库 - iScroll</h2><p>思路：<br>iScroll 通过对传统滚动事件的监听，获取滚动距离，然后：</p><ol><li>设置父元素的 translate 来实现整体内容的上移（下移）；</li><li>再基于这个滚动距离进行相应计算，得知相应子元素已经被滚动到视窗外，并且判断是否应该将这些离开视窗的子元素移动到末尾，从而再对它们进行 translate 的设置来移动到末尾。这就像是一个循环队列一样，随着滚动的进行，顶部元素先出视窗，但又将移动到末尾，从而实现无限下拉</li></ol><h2 id="方案一和二对比"><a href="#方案一和二对比" class="headerlink" title="方案一和二对比"></a>方案一和二对比</h2><ul><li>实现对比：一个是 Intersection Observer 的监听，来通知子元素离开视窗，只要定量设置父元素 padding 就行；另一个是对传统滚动事件的监听，滚动距离的获取，再进行一系列计算，去设置父元素以及子元素的 translate。显而易见，前者看起来更加简洁明了一些</li><li>性能对比：我知道说到对比，你脑海中肯定一下子会想到性能问题。其实性能对比的关键就是 Intersection Observer。因为单就 padding 设置还是 translate 设置，性能方面的差距是甚小的，只是个人感觉 padding 会简洁些？而 Intersection Observer 其实抽离了所有滚动层面的相关逻辑，你不再需要对滚动距离等相应 DOM 属性进行获取，也不再需要进行一系列滚动距离相关的复杂计算，并且同步的滚动事件触发变成异步的，你也不再需要另外去做防抖之类的逻辑，这在性能方面还是有所提升的</li></ul><h1 id="tree组件的渲染优化"><a href="#tree组件的渲染优化" class="headerlink" title="tree组件的渲染优化"></a>tree组件的渲染优化</h1><h1 id="高性能渲染10万个DOM"><a href="#高性能渲染10万个DOM" class="headerlink" title="高性能渲染10万个DOM"></a>高性能渲染10万个DOM</h1><p>见之前的博客<a href="https://jacleklm.github.io/2019/11/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化-如何插入几万个 DOM 并不卡住界面</a></p><p>参考资料<br><a href="https://mp.weixin.qq.com/s/X2ltQyp3W0othLv_m6-Ydg">云音乐-一个简洁、有趣的无限下拉方案</a><br><a href="https://zhuanlan.zhihu.com/p/55528376">前端tree组件，10000个树节点，从14.65s到0.49s</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;长列表-无限下拉列表-渲染&quot;&gt;&lt;a href=&quot;#长列表-无限下拉列表-渲染&quot; class=&quot;headerlink&quot; title=&quot;长列表 &amp;#x2F; 无限下拉列表 渲染&quot;&gt;&lt;/a&gt;长列表 &amp;#x2F; 无限下拉列表 渲染&lt;/h1&gt;&lt;p&gt;考虑到性能，我们不可能将</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="解决方案" scheme="http://jacleklm.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>哈希表 &amp; 哈希算法</title>
    <link href="http://jacleklm.github.io/2020/05/26/%E5%93%88%E5%B8%8C%E8%A1%A8%20&amp;%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://jacleklm.github.io/2020/05/26/%E5%93%88%E5%B8%8C%E8%A1%A8%20&amp;%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-26T02:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="哈希表-散列表"><a href="#哈希表-散列表" class="headerlink" title="哈希表 (散列表)"></a>哈希表 (散列表)</h2><p>在线性表中，所有的数据都是顺序存储，当我们需要在线性表中查找某一数据时，当线性表过长，需要查找的数据排序比较靠后的话，就需要花费大量的时间，导致查找性能较差</p><p>所以我们可以把数据存在哈希表中，通过 key 去拿到数据。这个过程可以描述为：</p><blockquote><p>拿到key(关键字) &gt; 关键字通过散列函数(哈希函数)计算出来的值则称为散列值（哈希值、Hash 值） &gt; 过散列值到**散列表（哈希表、Hash 表)**中就可以获取检索值</p></blockquote><p>如下图：<br><img src="/img/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>所以我们需要存的信息有：key，散列函数，散列表信息。所以，散列表是一种空间换时间的存储结构，是在算法中提升效率的一种比较常用的方式。</p><p>散列函数的作用就是给定一个键值，然后返回值在表中的地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 散列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HashTable</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> table = []</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><strong>哈希函数（Hash Function），也称为散列函数或杂凑函数</strong>。哈希函数是一个公开函数，可以将任意长度的消息M映射成为一个长度较短且长度固定的值H（M），称H（M）为哈希值、散列值（Hash Value）、杂凑值或者消息摘要（Message Digest）。<strong>它是一种单向密码体制，即一个从明文到密文的不可逆映射，只有加密过程，没有解密过程</strong>。</p><p>它的函数表达式为：<code>h = H(m)</code></p><p>无论输入是什么数字格式、文件有多大，输出都是固定长度的比特串。eg. 以比特币使用Sh256算法，无论输入是什么数据文件，输出就是256bit。<br>每个bit就是一位0或者1，256bit就是256个0或者1二进制数字串，用16进制数字表示的话: 16等于2的4次方，所以每一位16进制数字可以代表4位bit，所以256位bit用16进制数字表示是256除以4等于64位。<br>于是我们通常看到的哈希值，是这样的：</p><blockquote><p>00740f40257a13bf03b40f54a9fe398c79a664bb21cfa2870ab07888b21eeba8</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>易压缩：对于任意大小的输入x，Hash值的长度很小，在实际应用中，函数H产生的Hash值其长度是固定的。</li><li>易计算：对于任意给定的消息，计算其Hash值比较容易。</li><li>单向性：对于给定的Hash值，要找到使得在计算上是不可行的，即求Hash的逆很困难。在给定某个哈希函数H和哈希值H（M）的情况下，得出M在计算上是不可行的。即从哈希输出无法倒推输入的原始数值。这是哈希函数安全性的基础。</li><li>抗碰撞性：理想的Hash函数是无碰撞的，但在实际算法的设计中很难做到这一点。有两种抗碰撞性：一种是弱抗碰撞性，即对于给定的消息，要发现另一个消息，满足在计算上是不可行的；另一种是强抗碰撞性，即对于任意一对不同的消息，使得在计算上也是不可行的。</li><li>高灵敏性：这是从比特位角度出发的，指的是1比特位的输入变化会造成1&#x2F;2的比特位发生变化。消息M的任何改变都会导致哈希值H（M）发生改变。即如果输入有微小不同，哈希运算后的输出一定不同。</li></ul><h1 id="哈希算法的要求"><a href="#哈希算法的要求" class="headerlink" title="哈希算法的要求"></a>哈希算法的要求</h1><p>一个可靠的哈希算法，应该满足：</p><ul><li>对于给定的数据M,很容易算出哈希值X&#x3D;F(M)；根据X很难反算出M</li><li>很难找到M和N使得F(N)&#x3D;F(M)（这个可能是加密领域的，其实在储存领域，为了节省空间，key 值不同，通过散列函数计算出来的散列值（value）不一定不相同）</li></ul><p>哈希函数更多设计方法和冲突解决方法详见<a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/49">哈希表问题</a></p><h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>一个初始值值对应一个唯一的结果值，根据结果还推算不出来初始值，这可以通过<strong>丢掉一部分信息</strong>的加密方式实现，称为“单向加密”，也叫哈希算法。一个简单的例子：取注册者注册的时间戳的后6位再乘6取后6位，勉勉强强可以算是一个哈希算法。</p><h1 id="常见的哈希算法（加密领域）"><a href="#常见的哈希算法（加密领域）" class="headerlink" title="常见的哈希算法（加密领域）"></a>常见的哈希算法（加密领域）</h1><ul><li>SHA-1算法</li><li>SHA-2算法</li><li>SHA-512算法</li><li>SHA-3算法</li><li>RIPEMD160算法</li><li>…</li></ul><blockquote><p>这些算法的过程大概包括：输入 &gt; 消息填充 &gt; 链接变量初始化 &gt; 处理主循环模块 &gt; 得出最终的Hash值</p></blockquote><p>算法的具体细节见<a href="https://mp.weixin.qq.com/s/O0YGl4U14CNRX_t27khq8w">哈希算法</a></p><p>参考资料<br><a href="https://mp.weixin.qq.com/s/O0YGl4U14CNRX_t27khq8w">哈希算法</a><br><a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/49">前端瓶子君</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;h2 id=&quot;哈希表-散列表&quot;&gt;&lt;a href=&quot;#哈希表-散列表&quot; class=&quot;headerlink&quot; title=&quot;哈希表 (散列表)&quot;&gt;</summary>
      
    
    
    
    <category term="Basic knowledge" scheme="http://jacleklm.github.io/categories/Basic-knowledge/"/>
    
    
    <category term="Data structure" scheme="http://jacleklm.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>React - Hook</title>
    <link href="http://jacleklm.github.io/2020/05/23/React%20-%20Hook/"/>
    <id>http://jacleklm.github.io/2020/05/23/React%20-%20Hook/</id>
    <published>2020-05-23T08:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.869Z</updated>
    
    <content type="html"><![CDATA[<p>本文大部分来自<a href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a>，建议直接看原博客</p><h1 id="What-Why"><a href="#What-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h1><p>使用 Hooks，你可以在将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks 可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案<br>解决了 HOC 嵌套地狱的问题，使得逻辑复用更加清晰</p><h1 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h1><p>useState 是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值</p><h1 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h1><p>Effect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>第一个参数是回调函数，在第组件一次 render 和之后的每次 update 后运行，React 保证在 DOM 已经更新完成之后才会运行回调；这个回调函数可以 return 一个函数，<strong>在执行下一个 useEffect 之前，会执行这个函数</strong>，常常用来对上一次调用 useEffect 进行清理，并且可以拿到上一次的状态（原理是闭包）</li><li>第二个参数是状态依赖</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="模拟生命周期"><a href="#模拟生命周期" class="headerlink" title="模拟生命周期"></a>模拟生命周期</h3><ul><li>componentDidMount：状态依赖为空数组即可（其实官方并不推荐这种写法）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useDidMount</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(callback, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentWillUnmount：作为回调函数的 return 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useUnMount</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> callback, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ref-Hook"><a href="#ref-Hook" class="headerlink" title="ref Hook"></a>ref Hook</h1><p>用来获取 DOM 的 ref</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onButtonClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 useRef()并不仅仅可以用来当作获取 ref 使用，使用 useRef 产生的 ref 的 current 属性是可变的，这意味着你可以用它来保存一个任意值</p><h2 id="模拟-componentDidUpdate"><a href="#模拟-componentDidUpdate" class="headerlink" title="模拟 componentDidUpdate"></a>模拟 componentDidUpdate</h2><p>componentDidUpdate 就相当于除去第一次调用的 useEffect，我们可以借助 useRef 生成一个标识，来记录是否为第一次执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useDidUpdate</span>(<span class="params">callback, prop</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> init = <span class="title function_">useRef</span>(<span class="literal">true</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.<span class="property">current</span>) &#123;</span><br><span class="line">      init.<span class="property">current</span> = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h1><p>自定义 Hook 非常简单，我们只需要定义一个函数，并且把相应需要的状态和 effect 封装进去，同时，Hook 之间也是可以相互引用的。使用 use 开头命名自定义 Hook，这样可以方便 eslint 进行检查。<br>自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，<strong>它就像一个正常的函数</strong></p><h2 id="使用-Hook-的动机"><a href="#使用-Hook-的动机" class="headerlink" title="使用 Hook 的动机"></a>使用 Hook 的动机</h2><ul><li>减少状态逻辑复用的风险<ul><li>多个 Hook 之前不会相互影响，不会相互覆盖；Hook 也可以避免 HOC 使用不规范时的 props 覆盖</li></ul></li><li>避免嵌套地狱</li><li>让组件更容易理解：能用 Hook 讲公共逻辑抽离成函数，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割</li><li>函数代替 class</li></ul><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>useState 的 setXX 是异步函数，所以 setXXX 后立刻 console.log（XXX）的话是得不到的</li><li>在 setTimeout 这种闭包中中读不到其他状态的新值</li><li>记住 Hook 不能写在条件（if），循环（for），和嵌套函数中使用</li></ul><p>参考资料<br><a href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E5%9B%9B%EF%BC%89.html#effect-hook">ConardLi 的 blog</a><br><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文大部分来自&lt;a href=&quot;http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://jacleklm.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>React - HOC</title>
    <link href="http://jacleklm.github.io/2020/05/16/React%20-%20HOC/"/>
    <id>http://jacleklm.github.io/2020/05/16/React%20-%20HOC/</id>
    <published>2020-05-16T08:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.868Z</updated>
    
    <content type="html"><![CDATA[<p>本文大部分来自<a href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a>，建议直接看原博客</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Mixin-的危害"><a href="#Mixin-的危害" class="headerlink" title="Mixin 的危害"></a>Mixin 的危害</h2><p>React 官方文档在<a href="https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html">Mixins Considered Harmful</a>一文中提到了 Mixin 带来了危害：</p><ul><li>Mixin 可能会相互依赖，相互耦合，不利于代码维护</li><li>不同的 Mixin 中的方法可能会相互冲突</li><li>Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ul><p>React 现在已经不再推荐使用 Mixin 来解决<strong>代码复用</strong>问题，因为 Mixin 带来的危害比他产生的价值还要巨大，并且 React 全面推荐使用高阶组件来替代它</p><h2 id="HOC-简介"><a href="#HOC-简介" class="headerlink" title="HOC 简介"></a>HOC 简介</h2><p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">HOC-官方文档</a><br>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身<strong>不是 React API 的一部分</strong>，它是一种基于 React 的组合特性而形成的<strong>设计模式</strong></p><p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。实现在原有组件的基础上对其新增功能和行为</p><h1 id="HOC-的实现方式"><a href="#HOC-的实现方式" class="headerlink" title="HOC 的实现方式"></a>HOC 的实现方式</h1><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><p>常用方式，一般是在 render() 返回被包裹的组件，并把需要的 props 传递给它</p><h3 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">visibleHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; visible, ...restProps &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="keyword">if</span> (visible === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><p>假设有一个组件要在 localStorage 拿数据，然后渲染出来，它的代码应该差不多长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有很多其他组件也需要从 LocalStorage 中获取同样的数据展示出来时，那我要写很多次这段代码，为了效率我决定写用装饰器模式包装一下，所以就有了高阶组件（高阶组件本质是函数，所以这里写成函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">localHOC</span>(<span class="params">InnerComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 通过&#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比原生组件增强的项：</p><ul><li>可操作所有传入的 props</li><li>可操作组件的生命周期</li><li>可操作组件的 static 方法</li><li>获取 refs</li></ul><h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><p>返回一个组件，继承原组件，在 render 中用 super.render() 调用原组件的 render。由于继承了原组件，能通过 this 访问到原组件的生命周期、props、state、render 等，相比属性代理它能操作更多的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritHOC</span>(<span class="params">InnerComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">InnerComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比原生组件增强的项：</p><ul><li>可操作所有传入的 props</li><li>可操作组件的生命周期</li><li>可操作组件的 static 方法</li><li>获取 refs</li><li>可操作 state</li><li>可以渲染劫持</li></ul><h1 id="HOC-可以实现什么功能"><a href="#HOC-可以实现什么功能" class="headerlink" title="HOC 可以实现什么功能"></a>HOC 可以实现什么功能</h1><h2 id="组合渲染（常用）"><a href="#组合渲染（常用）" class="headerlink" title="组合渲染（常用）"></a>组合渲染（常用）</h2><p>可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果</p><p>eg. 一个在外层给组件包裹 Antd 的 Card 的 HOC。这里用了函数组件的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Card</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CardHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title = <span class="literal">null</span>, ...restProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过反向继承再实现一次。这里是 class 组件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CardHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">InnerComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Card</span> <span class="attr">title</span>=<span class="string">&#123;this.props.title&#125;</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件渲染（常用）"><a href="#条件渲染（常用）" class="headerlink" title="条件渲染（常用）"></a>条件渲染（常用）</h2><p>根据特定的属性决定原组件是否渲染。第一个 DEMO 就是这个</p><h2 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h2><p>可以对传入组件的 props 进行增加、修改、删除或者根据特定的 props 进行特殊的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">propsHOC</span> = (<span class="params">InnerComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">user_name</span>: <span class="string">&#x27;Jacle&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">InnerComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取-ref"><a href="#获取-ref" class="headerlink" title="获取 ref"></a>获取 ref</h2><p>高阶组件中可获取原组件的<a href="https://react.docschina.org/docs/refs-and-the-dom.html">ref</a>，通过 ref 获取组件实例，如下面的代码，当程序初始化完成后调用原组件的 log 方法 （默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例）。适合用 ref 的情况：管理 input 的 focus；触发强制动画；…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wapperRef</span>.<span class="title function_">log</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(ref)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            this.wapperRef = ref</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意：调用高阶组件的时候并不能获取到原组件的真实 ref，需要手动进行传递。详见<a href="https://react.docschina.org/docs/forwarding-refs.html">refs 转发</a></p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>将原组件的状态提取到 HOC 中进行管理，如下面的代码，我们将 Input 的 value 提取到 HOC 中进行管理，使它变成受控组件，同时不影响它使用 onChange 方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHoc</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onChange &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onChange === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">onChange</span>(event)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">onChange</span>: <span class="variable language_">this</span>.<span class="property">onChange</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOC</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">proxyHoc</span>(<span class="variable constant_">HOC</span>)</span><br></pre></td></tr></table></figure><h2 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h2><p>上面的例子通过属性代理利用 HOC 的 state 对原组件进行了一定的增强，但并不能直接控制原组件的 state，而通过<strong>反向继承</strong>，我们可以直接操作原组件的 state。但是并<strong>不推荐直接修改或添加原组件的 state</strong>，因为这样有可能和组件内部的操作构成冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debugHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props&#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;debuging&quot;</span>&gt;</span>&#123;super.render()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h2><p>通过反向继承的方式，可直接增强（而不是更改）由原组件 render 函数产生的 React 元素，eg：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hijackHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> tree = <span class="variable language_">super</span>.<span class="title function_">render</span>() <span class="comment">// render函数内实际上是调用React.creatElement产生的React元素。它所有属性的writable特性均被配置为了false，即所有属性是不可变的。所以我们只能重新创造一个元素，用React.cloneElement()</span></span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (tree &amp;&amp; tree.<span class="property">type</span> === <span class="string">&#x27;input&#x27;</span>) &#123;</span><br><span class="line">        newProps = &#123; <span class="attr">value</span>: <span class="string">&#x27;渲染被劫持了&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, tree.<span class="property">props</span>, newProps)</span><br><span class="line">      <span class="keyword">const</span> newTree = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(tree, props, tree.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">      <span class="keyword">return</span> newTree</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>React.cloneElement()克隆并返回一个新的 React 元素，使用 element 作为起点。生成的元素将会拥有原始元素 props 与新 props 的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。</p></blockquote><h1 id="HOC-的优雅写法"><a href="#HOC-的优雅写法" class="headerlink" title="HOC 的优雅写法"></a>HOC 的优雅写法</h1><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>在实际应用中，一个组件可能被多个 HOC 增强，我们使用的是被所有的 HOC 增强后的组件。直接写的话代码可读性会很差：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newComponent = <span class="title function_">aHOC</span>(<span class="title function_">bHOC</span>(<span class="title function_">cHOC</span>(<span class="title class_">InnerComponent</span>)))</span><br></pre></td></tr></table></figure><p>我们可以用类似柯里化的方式，手动封装一个简单的函数组合工具，将写法改写如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...fns</span>) =&gt; fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">g</span>(<span class="title function_">f</span>(...args)))</span><br><span class="line"><span class="title function_">compose</span>(aHOC, bHOC, cHOC)(<span class="title class_">InnerComponent</span>)</span><br></pre></td></tr></table></figure><h2 id="ES7-的-Decorators"><a href="#ES7-的-Decorators" class="headerlink" title="ES7 的 Decorators"></a>ES7 的 Decorators</h2><p><a href="https://es6.ruanyifeng.com/#docs/decorator">ES7-Decorators</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cHOC</span>(<span class="params">InnerComponent</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@aHOC</span><br><span class="line">@bHOC</span><br><span class="line">@cHOC</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这个InnerComponent等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"><span class="title class_">InnerComponent</span> = <span class="title function_">aHOC</span>(<span class="title class_">InnerComponent</span>) || <span class="title class_">InnerComponent</span></span><br></pre></td></tr></table></figure><p>Decorators 是 ES7 的一个提案，还没有被标准化，但目前 Babel 转码器已经支持，我们需要提前配置 babel-plugin-transform-decorators-legacy：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-decorators-legacy&quot;</span>]</span><br></pre></td></tr></table></figure><p>还可以结合上面的 compose 函数使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hoc = <span class="title function_">compose</span>(aHOC, bHOC, cHOC)</span><br><span class="line">@hoc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-HOC-的注意事项"><a href="#使用-HOC-的注意事项" class="headerlink" title="使用 HOC 的注意事项"></a>使用 HOC 的注意事项</h1><ul><li>静态属性拷贝<br>当我们应用 HOC 去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在 HOC 的结尾手动拷贝他们：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">HOCComponent</span>.<span class="property">staticMethod</span> = <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">HOCComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用<a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来帮助我们解决这个问题，它可以自动帮我们拷贝所有非 React 的静态方法，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxyHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HOCComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hoistNonReactStatic</span>(<span class="title class_">HOCComponent</span>, <span class="title class_">WrappedComponent</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">HOCComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Refs 不会被传递给被包装组件</li><li>不要在组件的 render 方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。因为高阶组件每次都会返回一个新的组件，在 render 中使用会导致每次渲染出来的组件都不相等（&#x3D;&#x3D;&#x3D;），于是每次 render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了</li><li>约定：不要改变原始组件。高阶组件应该是一个没有副作用的纯函数 (函数的调用参数相同，则永远返回相同的结果)</li><li>约定：透传不相关的 props。即 props 传递</li><li>约定：最好使用<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging">displayName</a>，方便调试。官方推荐使用 HOCName(WrappedComponentName)。eg. 赋予 return 组件一个静态属性：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> displayName = <span class="string">`aHOC(<span class="subst">$&#123;WrappedComponent.displayName&#125;</span>)`</span></span><br></pre></td></tr></table></figure><h1 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h1><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><p>多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用。eg，上面写过的 localstorage 的例子</p><h2 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h2><p>当没权限的时候不展示某个组件，就是上面提到的组合渲染</p><h2 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h2><p>eg. <a href="https://semi.bytedance.net/zh-CN/components/form">Semi</a> 中用 withField 封装自定义表单控件<br>通过 withField，你可以将其他自定义组件扩展成为表单控件，由 Form 接管其行为（value, onChange; 还有在上方插入Field 的<code>&lt;Label&gt;</code>， 下方插入 Field 的<code>&lt;ErrorMessage&gt;</code>等）</p><p>注意：自定义组件必须为受控组件，关于受控组件&#x2F;非受控组件请参考<a href="https://zh-hans.reactjs.org/docs/glossary.html#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-vs-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6">react docs</a></p><h2 id="Redux-的-connect"><a href="#Redux-的-connect" class="headerlink" title="Redux 的 connect"></a>Redux 的 <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect">connect</a></h2><p><img src="/img/React-HOC/connect.png"><br>下面就是一个简化版的connect实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">xport <span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Connect</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      <span class="attr">store</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">      <span class="variable language_">super</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">allProps</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_updateProps</span>()</span><br><span class="line">      store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_updateProps</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateProps () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">      <span class="keyword">let</span> stateProps = mapStateToProps ? <span class="title function_">mapStateToProps</span>(store.<span class="title function_">getState</span>(), <span class="variable language_">this</span>.<span class="property">props</span>): &#123;&#125; </span><br><span class="line">      <span class="keyword">let</span> dispatchProps = mapDispatchToProps? <span class="title function_">mapDispatchToProps</span>(store.<span class="property">dispatch</span>, <span class="variable language_">this</span>.<span class="property">props</span>) : &#123;&#125; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">allProps</span>: &#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...<span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state.allProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Connect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect函数其实就做了一件事: 将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>嵌套太多 HOC，代码可读性会比较差</li><li>HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突</li></ul><p>参考资料<br><a href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%B0Hook%EF%BC%88%E4%B8%80%EF%BC%89.html#%E5%AF%BC%E8%AF%BB">ConardLi 的 blog</a><br><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文大部分来自&lt;a href=&quot;http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E4%BB%8EMixin%E5%88%B0HOC%E5%86%8D%E5%88%</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://jacleklm.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>CSS Modules</title>
    <link href="http://jacleklm.github.io/2020/04/30/CSS%20Modules/"/>
    <id>http://jacleklm.github.io/2020/04/30/CSS%20Modules/</id>
    <published>2020-04-30T02:20:21.000Z</published>
    <updated>2023-09-17T14:00:22.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CSS Modules 不同于 less，sass 等，不是把CSS改造成编程语言，而是功能很单纯，只加入了局部作用域和模块依赖</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul><li>全局样式冲突（主要问题）</li><li>css选择器嵌套过深，有性能问题</li><li>代码冗余（无继承）</li><li>模块化</li></ul><h1 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h1><p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。这使得在开发中很可能有类名相同造成相互影响的情况，多层嵌套css又会造成性能问题。</p><p>产生局部作用域的唯一方法，就是使用一个独一无二的<strong>class的名字</strong>，不会与其他选择器重名。这就是 CSS Modules 的做法</p><h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>一个React组件App.js。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import style from &#x27;./App.css&#x27;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 className=&#123;style.title&#125;&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>App.css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">// 这种写法等于：</span><br><span class="line">:local &#123;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建工具会将类名style.title编译成一个哈希字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class=&quot;_3zyde4l1yATCOkgn-DBWEL&quot;&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>App.css也会同时被编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">._3zyde4l1yATCOkgn-DBWEL &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack的支持"><a href="#webpack的支持" class="headerlink" title="webpack的支持"></a>webpack的支持</h2><p>要开启 CSS Modules 功能，在webpack的loader配置中要有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  loader: &quot;style-loader!css-loader?modules&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>style-loader!css-loader?modules</code>，它在css-loader后面加了一个查询参数 <code>modules</code>，表示打开 CSS Modules 功能<br>与 sass， less 联用时同理</p><h1 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h1><p>允许使用<code>:global(.className)</code>的语法，声明一个全局规则。凡是这样声明的class，都不会被编译成哈希字符串，而是保留类名<br>css:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:global(.title) &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line">// 更常用的写法：</span><br><span class="line">:global &#123;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">  &lt;div className=&quot;title&quot;&gt;Hello World!&lt;div&gt;</span><br></pre></td></tr></table></figure><p>结果会是 green</p><h1 id="定制哈希类名"><a href="#定制哈希类名" class="headerlink" title="定制哈希类名"></a>定制哈希类名</h1><p>css-loader默认的哈希算法是<code>[hash:base64]</code>，这会将.title编译成.<code>_3zyde4l1yATCOkgn-DBWEL</code>这样的字符串。</p><p>webpack.config.js里面可以定制哈希字符串的格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    // ...</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      loader: &quot;style-loader!css-loader?modules&amp;localIdentName=[path][name]---[local]---[hash:base64:5]&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现<code>.title</code>被编译成了<code>demo03-components-App---title---GpMto</code></p><h1 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h1><h2 id="组合-composition"><a href="#组合-composition" class="headerlink" title="组合 composition"></a>组合 composition</h2><p>在App.css中，让.title继承 .className 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.className &#123;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.title &#123;</span><br><span class="line">  composes: className;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入其他模块"><a href="#输入其他模块" class="headerlink" title="输入其他模块"></a>输入其他模块</h2><p>选择器也可以继承其他CSS文件里面的规则。<br>another.css:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.className &#123;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App.css可以继承another.css里面的规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  composes: className from &#x27;./another.css&#x27;;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>这些和 less，sass 等联合使用</p><h2 id="关于样式覆盖问题"><a href="#关于样式覆盖问题" class="headerlink" title="关于样式覆盖问题"></a>关于样式覆盖问题</h2><p>因为CSS Modules 不会覆盖属性选择器,所以可以利用属性选择器来解决这个问题<br>&#x2F;&#x2F; 组件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div data-role=&#x27;test&#x27;&gt;</span><br><span class="line">    测试</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[data-role=&quot;test&quot;] &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料<br><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">阮一峰</a><br><a href="https://www.cnblogs.com/kugeliu/p/7889018.html">博客园</a><br><a href="https://juejin.im/post/5b8373b2e51d4538e6332dbb">掘金</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;CSS Modules 不同于 less，sass 等，不是把CSS改造成编程语言，而是功能很单纯，只加入了局部作用域和模块依赖&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="http://jacleklm.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript基础语法小结</title>
    <link href="http://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://jacleklm.github.io/2020/04/14/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2020-04-14T09:25:21.000Z</published>
    <updated>2023-09-17T14:00:22.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识-TypeScript"><a href="#初识-TypeScript" class="headerlink" title="初识 TypeScript"></a>初识 TypeScript</h1><h2 id="什么是-TS"><a href="#什么是-TS" class="headerlink" title="什么是 TS"></a>什么是 TS</h2><blockquote><p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上</p></blockquote><h2 id="TS-的优点和缺点"><a href="#TS-的优点和缺点" class="headerlink" title="TS 的优点和缺点"></a>TS 的优点和缺点</h2><p>优点：</p><ul><li>增加了代码的可读性和可维护性。写代码的时候有更多的编译提示，代码语义更清晰易懂</li><li>包容性</li><li>拥有活跃的社区</li></ul><p>缺点：</p><ul><li>一定的学习成本；短期可能会增加一些开发成本，毕竟要多写一些类型的定义</li><li>集成到构建流程需要一些工作量</li><li>可能和一些库结合的不是很完美</li></ul><p>详见 <a href="https://ts.xcatliu.com/introduction/what-is-typescript">什么是 TS</a></p><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><ul><li>编译代码：在命令行用 tsc &lt;文件名&gt; 的方式编译 .ts 文件，</li><li>运行代码：然后用 node 执行生成的 js 文件</li><li>安装了 ts-node 之后可以在命令行直接 ts-node &lt;文件名&gt; 的方式编译并执行 .ts 文件</li></ul><h2 id="静态类型的深度理解"><a href="#静态类型的深度理解" class="headerlink" title="静态类型的深度理解"></a>静态类型的深度理解</h2><ul><li>指定变量的类型</li><li>变量会具有这个类型的属性和方法</li></ul><h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>个人理解：<strong>对象类型</strong>就是<strong>非基础类型</strong>，包括 函数，自定义类型，类 等</p><p>基础类型中，布尔值，数字，字符串基本和 JS 一样；数组有两种定义方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种（较常用）</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>一种数组，表示一个已知元素数量和类型的数组，各元素的类型不必相同。eg：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Jacle&#x27;</span>, <span class="number">23</span>]</span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代 (联合类型：联合类型表示一个值可以是几种类型之一。用 | 产生)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Jacle&#x27;</span>, ’<span class="number">23</span>’]</span><br><span class="line"><span class="title class_">List</span>[<span class="number">3</span>] = <span class="string">&#x27;Chen&#x27;</span> <span class="comment">// 可以执行，是string，number 的一种. // 其实还是会报错，说这个元组没有index3</span></span><br><span class="line">list[<span class="number">4</span>] = <span class="literal">true</span> <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote><p>普通 JS 的情况</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Status</span> = &#123; <span class="comment">// eg. 处理一些后端code会用到这种写法</span></span><br><span class="line">  <span class="attr">OFFLINE</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">ONLINE</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">DELETED</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getResult</span>(<span class="params">status</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">OFFLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;offline&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">ONLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;online&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">DELETED</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deleted&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getResult</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><blockquote><p>应用枚举的情况</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OFFLINE</span>,</span><br><span class="line">  <span class="variable constant_">ONLINE</span>,</span><br><span class="line">  <span class="variable constant_">DELETED</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getResult</span>(<span class="params">status</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">OFFLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;offline&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">ONLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;online&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="title class_">Status</span>.<span class="property">DELETED</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deleted&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getResult</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>);</span><br></pre></td></tr></table></figure><h4 id="枚举成员的初始化"><a href="#枚举成员的初始化" class="headerlink" title="枚举成员的初始化"></a>枚举成员的初始化</h4><ul><li>不对枚举成员的元素进行初始化的时候，默认其值是 0，1，2 … ；给某个成为初始化为某个数字都时候，后面的成员会默认接着这个数字进行初始化</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OFFLINE</span>,</span><br><span class="line">  <span class="variable constant_">ONLINE</span>,</span><br><span class="line">  <span class="variable constant_">DELETED</span> = <span class="number">100</span>,</span><br><span class="line">  <span class="variable constant_">TEST</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Status</span>.<span class="property">OFFLINE</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>[<span class="number">0</span>]) <span class="comment">// OFFLINE 反向查枚举成员的名称</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Status</span>[<span class="number">0</span>]) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">ONLINE</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">DELETED</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">TEST</span>) <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><ul><li>对某个成员初始化为非数字类型时，接下来的其他成员都得进行显式初始化，直到某个成员被显示初始化为数字类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">  <span class="variable constant_">OFFLINE</span>,</span><br><span class="line">  <span class="variable constant_">ONLINE</span> = <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">DELETED</span> = <span class="string">&#x27;chen&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">TEST</span> = <span class="number">10</span>,</span><br><span class="line">  <span class="title class_">TETS2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">OFFLINE</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">ONLINE</span>) <span class="comment">// jacle</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">DELETED</span>) <span class="comment">// chen</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">TEST</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Status</span>.<span class="property">TETS2</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>更详见 <a href="https://www.tslang.cn/docs/handbook/enums.html">官方文档：枚举</a></p><h3 id="any-常用"><a href="#any-常用" class="headerlink" title="any (常用)"></a>any (常用)</h3><p>我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">&#x27;maybe a string instead&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;free&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void 类型像是与 any 类型相反，它表示没有任何类型。一般用于函数没返回值的时候使用；void 变量则只能赋值为 undefined 和 null</p><h3 id="undefined-和-null-少用"><a href="#undefined-和-null-少用" class="headerlink" title="undefined 和 null (少用)"></a>undefined 和 null (少用)</h3><p>两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大</p><h3 id="never-少用"><a href="#never-少用" class="headerlink" title="never (少用)"></a>never (少用)</h3><p>never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。eg：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>使用类型断言的时候，TS 认为程序员已经很确定这个变量的类型了，会假设程序员已经做了必须的检查，常和 <code>any</code> 搭配使用。有两种写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;&gt;写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someVal</span>: <span class="built_in">any</span> = <span class="string">&#x27;this is a string, I sure&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someVal).<span class="property">length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strLength) <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// as写法 (似乎比较好记)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someVal</span>: <span class="built_in">any</span> = <span class="string">&#x27;this is a string, I sure&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someVal <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br></pre></td></tr></table></figure><h2 id="类型注解（type-annotation）-类型推断-（type-inference）"><a href="#类型注解（type-annotation）-类型推断-（type-inference）" class="headerlink" title="类型注解（type annotation） &amp; 类型推断 （type inference）"></a>类型注解（type annotation） &amp; 类型推断 （type inference）</h2><p>类型注解：明显写出来的，我们告诉 TS 变量是什么类型</p><p>类型推断：TS 自动的去尝试分析变量类型。当 TS 无法分析出来的时候，就需要我们写类型注解</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>同 JS：var，let， const</p><h2 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h2><p>就是 type 这种语法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">User</span>[] = [&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserName</span> = <span class="string">&#x27;jacle&#x27;</span> | <span class="string">&#x27;jaclee&#x27;</span></span><br></pre></td></tr></table></figure><p>个人理解：类型别名 和 接口 的区别不大，类型别名 能表示基础类型，接口 只能表示对象类型；能用接口的时候尽量用接口</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约</p></blockquote><p>个人理解是：接口是对一类数据结构的约定和描述</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>可有可无的属性。eg：<code>color?: string;</code></p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只能在刚创建的时候赋值，后面不能修改，在接口的属性前加 <code>readonly</code>。eg:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">point1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">point1.<span class="property">x</span> = <span class="number">3</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>此外，TypeScript 的数组具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，效果一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>总结：不能变的属性用 readonly，不能变的变量用 const</p><h4 id="一个作用：接口可能带有任意数量的其它属性"><a href="#一个作用：接口可能带有任意数量的其它属性" class="headerlink" title="一个作用：接口可能带有任意数量的其它属性"></a>一个作用：接口可能带有任意数量的其它属性</h4><p>如果我们创建一个接口，该接口除了我们明确约定好的属性，还可能会带有任意数量的其它属性，我们这时候就可以用 添加一个字符串索引签名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是其实这种情况还有一个不用索引类型的知识点（虽然不太严谨）：直接传的对象有多余属性会报错，传的是变量的时候就不会</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">person: Person</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jacle = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&#x27;SYSU&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getName</span>(&#123; <span class="comment">// Error，school 不在 Person 中</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&#x27;SYSU&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">getName</span>(jacle) <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口也可以描述函数类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> searchFun &#123;</span><br><span class="line">  (<span class="attr">sour</span>: <span class="built_in">string</span>, <span class="attr">data</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">testFun</span>: searchFun = <span class="keyword">function</span>(<span class="params">sour: <span class="built_in">string</span>, data: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>接口也能用来描述类，强制一个类去满足某种契约。用 <code>implements</code><br>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInt</span> &#123;</span><br><span class="line">  <span class="attr">currTime</span>: <span class="title class_">Date</span>,</span><br><span class="line">  <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInt</span> &#123;</span><br><span class="line">  <span class="attr">currTime</span>: <span class="title class_">Date</span></span><br><span class="line">  <span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currTime</span> = d</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currTime</span> = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>一个接口可以继承一个或多个接口，创建出多个接口的合成接口。用 <code>extends</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> class1 &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> class2 &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> class3 &#123;</span><br><span class="line">  <span class="attr">city</span>: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> people <span class="keyword">extends</span> class1, class2, class3 &#123;</span><br><span class="line">  <span class="attr">ishandsome</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">jacle</span>: people = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">city</span>: [<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>],</span><br><span class="line">  <span class="attr">ishandsome</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可索引类型-索引签名"><a href="#可索引类型-索引签名" class="headerlink" title="可索引类型 &amp;&amp; 索引签名"></a>可索引类型 &amp;&amp; 索引签名</h2><p>接口也可以描述那些能够“通过索引得到”的类型，比如数组或对象: <code>a[10]</code> 或 <code>ageMap[&#39;daniel&#39;]</code>。 可索引类型具有一个<strong>索引签名</strong>，它描述了<strong>对象索引的类型，还有相应的索引返回值类型</strong>(两部分)</p><blockquote><p>一般情况下， 索引 和 索引签名 是一个概念；当我们<strong>声明一个索引签名</strong>的时候，就是声明了索引的类型，还有相应的索引返回值类型（两部分）</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StrArr</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span> <span class="comment">// 暂时理解为这部分是索引签名。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strA</span>: <span class="title class_">StrArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: <span class="built_in">string</span> = strA[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p>这个 index 只是发挥可读性的作用，你可以随便命名</p></blockquote><h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a><a href="https://jkchao.github.io/typescript-book-chinese/typings/indexSignatures.html#typescript-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D">索引签名</a></h3><p>可看文档</p><h3 id="JS中"><a href="#JS中" class="headerlink" title="JS中"></a>JS中</h3><ol><li>在JS中，一般认为索引签名的类型是字符串和数字<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jacle = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jacle&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle[<span class="string">&#x27;name&#x27;</span>]) <span class="comment">// 索引签名是字符串</span></span><br><span class="line"><span class="keyword">let</span> people = [jacle]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people[<span class="number">0</span>]) <span class="comment">// 索引签名是数字</span></span><br></pre></td></tr></table></figure></li><li>当我们把索引签名搞成对象时，JavaScript 会在得到结果之前会先调用 .toString 方法：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString called&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">any</span> = &#123;&#125;;</span><br><span class="line">foo[obj] = <span class="string">&#x27;World&#x27;</span>; <span class="comment">// toString called</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[obj]); <span class="comment">// toString called, World</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[<span class="string">&#x27;Hello&#x27;</span>]); <span class="comment">// World</span></span><br></pre></td></tr></table></figure><blockquote><p>只要索引位置使用了 obj，toString 方法都将会被调用</p></blockquote></li></ol><h3 id="TS中"><a href="#TS中" class="headerlink" title="TS中"></a>TS中</h3><p>TypeScript 的索引签名必须是 string 或者 number。我们搞 obj 进去会报错的，强制用户必须明确的写出 toString()</p><h4 id="声明一个索引签名"><a href="#声明一个索引签名" class="headerlink" title="声明一个索引签名"></a>声明一个索引签名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: &#123; <span class="attr">message</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 储存的东西必须符合结构</span></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">foo[<span class="string">&#x27;a&#x27;</span>] = &#123; <span class="attr">message</span>: <span class="string">&#x27;some message&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error, 必须包含 `message`</span></span><br><span class="line">foo[<span class="string">&#x27;a&#x27;</span>] = &#123; <span class="attr">messages</span>: <span class="string">&#x27;some message&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="所有成员都必须符合字符串的索引签名"><a href="#所有成员都必须符合字符串的索引签名" class="headerlink" title="所有成员都必须符合字符串的索引签名"></a>所有成员都必须符合字符串的索引签名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">string</span>; <span class="comment">// Error: y 属性必须为 number 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用字符串字面量-字符串组成的联合类型-当索引签名"><a href="#使用字符串字面量-字符串组成的联合类型-当索引签名" class="headerlink" title="使用字符串字面量(字符串组成的联合类型)当索引签名"></a>使用字符串字面量(字符串组成的联合类型)当索引签名</h4><p>一个索引签名可以通过<strong>映射类型</strong>来使索引字符串为联合类型中的一员：</p><blockquote><p>映射类型是 in、keyof、typeof 这些？</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> index = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> fromIndex = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> index]: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">good</span>: <span class="title class_">FromIndex</span> = &#123; <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// Error:</span></span><br><span class="line"><span class="comment">// `&#123; b: 1, c: 2, d: 3 &#125;` 不能分配给 &#x27;FromIndex&#x27;</span></span><br><span class="line"><span class="comment">// 对象字面量只能指定已知类型，&#x27;d&#x27; 不存在 &#x27;FromIndex&#x27; 类型上</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bad</span>: <span class="title class_">FromIndex</span> = &#123; <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="同时拥有-string-和-number-类型的索引签名-少用"><a href="#同时拥有-string-和-number-类型的索引签名-少用" class="headerlink" title="同时拥有 string 和 number 类型的索引签名(少用)"></a>同时拥有 string 和 number 类型的索引签名(少用)</h4><p>TypeScript 可以同时使用字符串和数字两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ArrStr</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>; <span class="comment">// 必须包括所用成员类型</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">// 字符串索引类型的子级</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// example</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">greeter.<span class="title function_">greet</span>()</span><br></pre></td></tr></table></figure><p>创建了一个 Greeter 类，有一个 greeting 属性，一个构造函数 constructor（所以构造函数中也得有 this.greeting）和一个 greet 方法</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>同 ES6</p><p>此外，子类可以通过直接重写方法的形式重写父类的方法；重写的时候如果想调用父类的方法可以用 super</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;jacle&#x27;</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getName</span>() + <span class="string">&#x27; new&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jacle = <span class="keyword">new</span> <span class="title class_">Teacher</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle.<span class="title function_">getName</span>()) <span class="comment">// ‘jacle new&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h3><p>类的属性，静态属性，方法，构造函数 都可以加这些修饰符前缀，默认都是 public</p><ul><li>默认为 public。外部可访问</li><li>private。外部不可访问，只有内部（这个类自己）的方法可以访问</li><li>protected。只有 类自己 和 类的后代 可以访问</li><li>也可加 readonly 修饰符，使得属性无法被后续修改</li></ul><p>注意下面这两种写法都可以：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">protected</span> message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><p>可以把属性写成 pravite 的，然后定义 getter 和 setter 进行属性的读改</p><p>用法：用 <code>get</code> 和 <code>set</code>，一般会和 pravite 属性配合使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> _name: <span class="built_in">string</span></span>) &#123; <span class="comment">// 内部属性可以用 _ 进行区分，可以和 get 相配合</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = _name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 可以加额外的处理逻辑</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="comment">// low 的写法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jacle2 = <span class="keyword">new</span> <span class="title class_">Person3</span>(<span class="string">&#x27;jacle&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle2.<span class="property">name</span>) <span class="comment">// 用了 get 之后可以直接这么用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle2.<span class="title function_">getName</span>())</span><br><span class="line">jacle2.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span> <span class="comment">// 调用了 setter</span></span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>属性加 static 前缀。静态属性存在于<strong>类本身</strong>上面而不是类的实例上，但是实例会用到这个属性，访问方法是 <code>类.静态属性</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChenFamilyPeo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> lastName = <span class="string">&#x27;Chen&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">firstname</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstname: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstname</span> = firstname</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ChenFamilyPeo</span>.<span class="property">lastName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">firstname</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jacle = <span class="keyword">new</span> <span class="title function_">chenFamilyPeo</span>(<span class="string">&#x27;Junjia&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jacle.<span class="title function_">getFullName</span>())  <span class="comment">// Chen Junjia</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ChenFamilyPeo</span>.<span class="property">lastName</span>)  <span class="comment">// Chen</span></span><br></pre></td></tr></table></figure><h4 id="应用举例：TS-中的单例模式"><a href="#应用举例：TS-中的单例模式" class="headerlink" title="应用举例：TS 中的单例模式"></a>应用举例：TS 中的单例模式</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleObj</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>: <span class="title class_">SingleObj</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">SingleObj</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title class_">SingleObj</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;jacle&#x27;</span>, <span class="number">23</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getAge</span>()) <span class="comment">// 23</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title class_">SingleObj</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;jacle&#x27;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 === person2) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getAge</span>()) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure><h3 id="抽象类-少用"><a href="#抽象类-少用" class="headerlink" title="抽象类 (少用)"></a>抽象类 (少用)</h3><p>抽象类做为其它派生类的基类使用（抽象子类 &#x3D;&#x3D;&#x3D; 派生类）。 它们一般不会直接被实例化。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法<br>并且派生类一定要有抽象类中定义的属性和方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Department name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name) <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generating accounting reports...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span> <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>() <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>(<span class="string">&#x27;客增研发&#x27;</span>) <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(department.<span class="property">name</span>) <span class="comment">// 客增研发</span></span><br><span class="line">department.<span class="title function_">printName</span>() <span class="comment">// Department name: 客增研发</span></span><br><span class="line">department.<span class="title function_">printMeeting</span>() <span class="comment">// The Accounting Department meets each Monday at 10am.</span></span><br><span class="line">department.<span class="title function_">generateReports</span>() <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完整函数类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: <span class="function">(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y:<span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选参数-默认参数"><a href="#可选参数-默认参数" class="headerlink" title="可选参数 &amp; 默认参数"></a>可选参数 &amp; 默认参数</h3><ul><li>TS 中参数是必须的，不能是 undifined，不能多也不能少。可以用 <code>?</code> 表示可选参数</li><li>默认参数同 ES6 如果位置靠前但是想启用默认参数，则传 undefined 即可</li></ul><p>当我们想传好几个参数，但是参数不是必选的时候，有时候执行起来会不太优雅：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">testFn</span> = (<span class="params">a?: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span> </span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>, a);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testFn</span>(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>可以改成这种对象的写法:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">testFn</span> = (<span class="params">ops: &#123; a?: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>, ops.<span class="property">a</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>, ops.<span class="property">c</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testFn</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>个人理解函数重载就是：函数根据传入不同的参数而返回不同类型的数据的场景 &#x2F; 执行不同的逻辑。<br>在 TS 当中，除了在函数内部写判断类型并具体执行的逻辑之外，还要在函数之前 为同一个函数提供多个函数类型定义来进行函数重载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): &#123;<span class="attr">suit</span>: <span class="built_in">string</span>; <span class="attr">card</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)) &#123;</span><br><span class="line">    <span class="comment">// 逻辑部分</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑部分</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">card</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在定义重载的时候，一定要把最精确的定义放在最前面</p></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，泛指的类型</p><p>个人理解：泛型主要是用来<strong>提高数据类型方面的复用性</strong>：组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，比单纯写 string | number 等这种联合类型写法复用性更高<br>进一步理解：泛形应该理解为一个储存池，用来保存可能会用到的类型，相当于<strong>加了若干个类型参数</strong>。捕获输入类型只是泛型的常见应用</p><h3 id="类型变量-T"><a href="#类型变量-T" class="headerlink" title="类型变量 T"></a>类型变量 T</h3><p>语法是 <code>&lt;T&gt;</code>，可以帮助我们捕获用户传入的类型，eg：定义一个会返回任何传入它的值的函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123; <span class="comment">// 编译器会认为 T 是任意类型，所以该函数具有强的通用性</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不好的写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123; <span class="comment">// 用any能有同样的效果，但是我们会丢失 参数类型 ，这个信息</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把这个版本的 identity 函数叫做泛型，因为它可以适用于多个类型。可以使用泛型来创建可重用的组件<br>我们可以这么用该函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="title function_">identity</span>(<span class="string">&#x27;jacle&#x27;</span>) <span class="comment">// 编译器会根据传入的参数自动地帮助我们确定 T 的类型</span></span><br></pre></td></tr></table></figure><h3 id="泛型类型-接口-类"><a href="#泛型类型-接口-类" class="headerlink" title="泛型类型 &amp; 接口 &amp; 类"></a>泛型类型 &amp; 接口 &amp; 类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> rec&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">newre</span>: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = rec</span><br></pre></td></tr></table></figure><p>泛型接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;T&gt; &#123;</span><br><span class="line">  (<span class="attr">arg</span>: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span>&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></table></figure><p>泛型类，与接口类似</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> join&lt;T&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">join&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>) <span class="comment">// 函数使用的时候可以显式地生命泛型是什么类型，显然这里会报错；不显式则会被推断出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> join&lt;T, P&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: P) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">join&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>) <span class="comment">// 泛型还可以定义多个，这里不会报错</span></span><br></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>泛型约束是一个很常用的用法</strong>，用来<strong>把类型约束成一个更严谨的类型</strong> (<strong>使得泛型收窄</strong>)，eg. 用来<strong>确保属性存在</strong>。其实泛型约束的方法挺多：extends这种简单的也算</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> rec&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>) <span class="comment">// error。编译的时候认为arg是任何类型，所以不一定有length属性</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以<strong>定义一个接口做一些约束</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> lengthwise &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> rec&lt;T <span class="keyword">extends</span> lengthwise&gt;(<span class="attr">arg</span>: T): T &#123; <span class="comment">// 意思是：T类型应该有length属性，并且该属性返回number</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">rec</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="title function_">rec</span>(<span class="number">6</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。eg:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[];  <span class="comment">// number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><p>所以有了 keyof 之后我们可以更愉快地和 泛型约束 玩耍</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K): T[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发中还遇到不懂的泛型骚操作，详见 <a href="https://mp.weixin.qq.com/s/9mvQcBM13Rt75dJpftVTIg">一文读懂 TypeScript 泛型及应用</a></p><h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>见<a href="https://jacleklm.github.io/2020/12/07/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/">TypeScript中的类型编程</a></p><h4 id="有时可发挥类似-interface-的作用"><a href="#有时可发挥类似-interface-的作用" class="headerlink" title="有时可发挥类似 interface 的作用"></a>有时可发挥类似 interface 的作用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">FeatureContext</span> = <span class="title class_">React</span>.<span class="property">createContext</span>&lt;&#123;</span><br><span class="line">  <span class="attr">featureList</span>: <span class="title class_">IFeature</span>[];</span><br><span class="line">  <span class="attr">supplementaryData</span>: <span class="title class_">ISupplementaryData</span>;</span><br><span class="line">  <span class="attr">fetchLoading</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">fetchFeatureData</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">searchFeature</span>(<span class="attr">queryKey</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">verifyId</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [fetchLoading, setFetchLoadingStatus] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="高级类型-其实用的还挺多的"><a href="#高级类型-其实用的还挺多的" class="headerlink" title="高级类型 (其实用的还挺多的)"></a>高级类型 (其实用的还挺多的)</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。用 &amp; 产生</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示一个值可以是几种类型之一。用 | 产生</p><h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><h4 id="通俗版"><a href="#通俗版" class="headerlink" title="通俗版"></a>通俗版</h4><p><strong>个人理解</strong>：类型保护一般出现在有联合类型的地方，类型保护就是用来判断变量类型的，并且在对应的 if 分支内能确定变量类型，进而能提前调用那种类型的函数 (比如提前判定是 string，然后在那个分支就可以用 .substr() )</p><h4 id="类型保护的方式"><a href="#类型保护的方式" class="headerlink" title="类型保护的方式"></a>类型保护的方式</h4><ul><li>类型断言</li><li>in语法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">sing</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="built_in">boolean</span></span><br><span class="line">  <span class="attr">bark</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型断言的类型保护</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trains1</span>(<span class="params">animal: Bird | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(animal.<span class="property">fly</span>) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> <span class="title class_">Bird</span>).<span class="title function_">sing</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> <span class="title class_">Dog</span>).<span class="title function_">bark</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in 语法的类型保护</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trains2</span>(<span class="params">animal: Bird | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&#x27;sing&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.<span class="title function_">sing</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">bark</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>typeof</li><li>instanceof<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 和 instanceof 语法的类型保护</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">first: <span class="built_in">string</span> | <span class="built_in">number</span>, second: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> first === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> second === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// instanceof 语法的类型保护 ，只用于能用 instanceof 的，eg. class (interface不能)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">numberObj</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">count: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add2</span>(<span class="params">first: <span class="built_in">object</span> | numberObj, second: <span class="built_in">object</span> | numberObj</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里不能写成 first instanceof numberObj === true</span></span><br><span class="line">  <span class="keyword">if</span>(first <span class="keyword">instanceof</span> numberObj &amp;&amp; second <span class="keyword">instanceof</span> numberObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> first.<span class="property">count</span> + second.<span class="property">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="官方版"><a href="#官方版" class="headerlink" title="官方版"></a>官方版</h4><p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型</p><p>定义一个<strong>类型保护</strong>，我们只要简单地定义一个<strong>函数</strong>，它的<strong>返回值是一个类型谓词</strong>：这里 <code>pet is Fish</code> 就是类型谓词</p><p>就是当下面这个函数返回true的时候，就会有 <code>pet is Fish</code>，在下面的 if 中相当于一种类型断言的作用了。<strong>所以这种函数类型其实也是一种类型保护</strong>，或者说是一种底层是类型断言的类型保护</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">swim</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can swim, i am fish&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I can fly, i am bird&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> petUnknow = <span class="keyword">new</span> <span class="title class_">Fish</span>(<span class="string">&#x27;pet&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trainAnimal</span>(<span class="params">pet: Fish | Bird</span>): <span class="built_in">void</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">    pet.<span class="title function_">swim</span>() <span class="comment">// 这里能这样调用而不会报错，因为这个分支认定 pet is Fish</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.<span class="title function_">fly</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">trainAnimal</span>(petUnknow) <span class="comment">// I can swim, i am fish</span></span><br></pre></td></tr></table></figure><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须具有的确切值.</p><blockquote><p>字符串字面量 &#x3D;&#x3D;&#x3D; 字符串组成的联合类型</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Easing</span> = <span class="string">&#x27;ease-in&#x27;</span> | <span class="string">&#x27;ease-out&#x27;</span> | <span class="string">&#x27;ease-in-out&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEase</span>(<span class="params">ease: Easing</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Typescript-中的-Record-Partial-Readonly-Pick"><a href="#Typescript-中的-Record-Partial-Readonly-Pick" class="headerlink" title="Typescript 中的 Record, Partial, Readonly , Pick"></a>Typescript 中的 Record, Partial, Readonly , Pick</h2><p><a href="https://jacleklm.github.io/2020/12/09/TypeScript%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">TypeScript中的内置工具类型及其实现</a></p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><a href="https://jkchao.github.io/typescript-book-chinese/project/namespaces.html">文档</a></p><h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><h2 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h2><p>使用方法。编译代码：在命令行用 tsc &lt;文件名&gt; 的方式编译 .ts 文件，然后用 node 执行生成的js文件</p><h2 id="tsconfig-json-配置文件及其常用语法"><a href="#tsconfig-json-配置文件及其常用语法" class="headerlink" title="tsconfig.json 配置文件及其常用语法"></a>tsconfig.json 配置文件及其常用语法</h2><p>在项目当中，根目录运行 <code>tsc --init</code> 能生成该项目的 TS 配置文件: tsconfig.json</p><h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><p>在根目录命令行单纯地执行 tsc ，会根据配置文件编译整个目录下所有的 .ts 文件（用ts-node ${fileName} 其实也会用这个配置文件) ；想只编译某些文件，可以 files &#x2F; include 或 exculde (数组写法）eg. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [&quot;./single.ts&quot;],</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h3><p><a href="https://www.tslang.cn/docs/handbook/compiler-options.html">官方文档</a></p><p>常用配置项：</p><ul><li>常规<ul><li>removeComments: true  编译时去除注释</li><li>Incremental: true  上次编译过并且没变化的文件这次不会再编译</li></ul></li><li>JS<ul><li>allowJs: true    允许编译javascript文件（转成ES5）</li><li>checkJs: true   检查JS语法</li></ul></li><li>检查<ul><li>noImplicitAny: true  当一个变量是 any 的时候，必须显示地写出来，不然会报错</li><li>strictNullChecks: true  在严格的 null检查模式下， null和 undefined值不包含在任何类型里，只允许用它们自己和 any来赋值</li></ul></li><li>输入输出<ul><li>outDir: “.&#x2F;build”</li><li>rootDir: “.&#x2F;src”  此时src文件外不能有 .ts 文件</li></ul></li><li>额外检查<ul><li>noUnusedLocals    若有未使用的局部变量则抛错</li><li>noUnusedParameters  同理，函数参数</li></ul></li></ul><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><ul><li>项目的script命令中写成 tsc -w ，这个 -w 能监控项目中 TS 文件的变化，有变化就自动重新编译</li></ul><p>参考资料<br><a href="https://ts.xcatliu.com/introduction/what-is-typescript">TypeScript 入门教程</a><br><a href="https://www.tslang.cn/docs/handbook/basic-types.html">TypeScript 官方文档</a><br><a href="https://coding.imooc.com/class/330.html">慕课网：基于 TypeScript 从零重构 axios</a><br><a href="https://coding.imooc.com/class/412.html">慕课网：TypeScript－系统入门到项目实战</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识-TypeScript&quot;&gt;&lt;a href=&quot;#初识-TypeScript&quot; class=&quot;headerlink&quot; title=&quot;初识 TypeScript&quot;&gt;&lt;/a&gt;初识 TypeScript&lt;/h1&gt;&lt;h2 id=&quot;什么是-TS&quot;&gt;&lt;a href=&quot;#什么是</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="http://jacleklm.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>洗牌算法</title>
    <link href="http://jacleklm.github.io/2020/03/08/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://jacleklm.github.io/2020/03/08/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-08T05:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何真正的打乱数组?</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>上述代码看似可以打乱，但是不是真正的打乱。做下测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">RandomShuffle</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testResult</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">100000</span></span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="title class_">RandomShuffle</span>(arr)</span><br><span class="line">    <span class="keyword">let</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr)</span><br><span class="line">    res[key] ? res[key]++ : (res[key] = <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为了方便展示，转换成百分比</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> res) &#123;</span><br><span class="line">    res[key] = (res[key] / times) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">testResult</span>()</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]: <span class="string">&quot;37.66%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]: <span class="string">&quot;12.57%&quot;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]: <span class="string">&quot;6.109%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]: <span class="string">&quot;6.343999999999999%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]: <span class="string">&quot;6.22%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]: <span class="string">&quot;31.097%&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出末尾数字是 3 的概率为 50%，而不是想象中的 33%。原因是因为 sort 函数底层是使用插入排序实现的。所以初始为[1,2,3]的时候，插入排序从 2 开始，和前面做比较，此时有 50%的几率顺序 50%的几率逆序，所以[1,2,3][2,1,3]出现几率都为 50%。接下来的操作如下图所示：<br><img src="/img/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95.png"></p><blockquote><p>Knuth-Durstenfeld 洗牌算法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">KnuthDurstenfeldShuffle</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 用结构赋值两项交换之前最好加 ;</span></span><br><span class="line">    ;[arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>选取数组(长度 n)中最后一个元素(arr[length-1])，将其与 n 个元素中的任意一个交换，此时最后一个元素已经确定</li><li>选取倒数第二个元素(arr[length-2])，将其与 n-1 个元素中的任意一个交换</li><li>重复第 1 2 步，直到剩下 1 个元素为止</li></ul><blockquote><p>Fisher-Yates 洗牌算法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 似乎有误</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">FisherYatesShuffle</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>)</span><br><span class="line">    result.<span class="title function_">push</span>(arr[randomIndex])</span><br><span class="line">    arr.<span class="title function_">splice</span>(randomIndex, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]: <span class="string">&quot;16.646%&quot;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]: <span class="string">&quot;16.633%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]: <span class="string">&quot;16.55%&quot;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]: <span class="string">&quot;16.787%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]: <span class="string">&quot;16.662%&quot;</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]: <span class="string">&quot;16.722%&quot;</span></span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>从还没处理的数组（假如还剩 n 个）中，产生一个[0, n]之间的随机数 random</li><li>从剩下的 n 个元素中把第 random 个元素取出到新数组中</li><li>删除原数组第 random 个元素</li><li>重复第 2 3 步直到所有元素取完</li><li>最终返回一个新的打乱的数组</li></ul><p>参考资料<br><a href="https://dannykbsoul.github.io/2020/03/03/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/">洗牌算法</a><br><a href="https://coolshell.cn/articles/8593.html">如何测试洗牌程序</a><br><a href="https://github.com/ccforward/cc/issues/44">洗牌算法(shuffle)的 js 实现</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如何真正的打乱数组?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="Basic knowledge" scheme="http://jacleklm.github.io/categories/Basic-knowledge/"/>
    
    
    <category term="Data structure" scheme="http://jacleklm.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>博客项目上线部署总结</title>
    <link href="http://jacleklm.github.io/2020/02/27/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    <id>http://jacleklm.github.io/2020/02/27/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/</id>
    <published>2020-02-27T07:49:21.000Z</published>
    <updated>2023-09-17T14:00:22.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过一番折腾之后项目终于上线了（喜极而泣，坑好多），博客项目部署在 <a href="http://jacleklm.com/">JacleKlm.com</a>，先写一篇文章记录下近期的折腾所得吧。</p><h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>买的<a href="https://cloud.tencent.com/act/season">腾讯云服务器</a>最便宜的那种，买域名，备案审批</p><p>云服务器中，更多-安全组-配置安全组-点连接，可以设置端口的开启及可以访问的人</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux 是一个性能稳定的多用户网络操作系统，经常用来跑服务器，eg. Linux + Nginx + MySQL + Node.js</p><h2 id="Linux-常见命令"><a href="#Linux-常见命令" class="headerlink" title="Linux 常见命令"></a>Linux 常见命令</h2><ul><li>Vim（用来打开文件）<ul><li>Vim 下，<code>i</code> 是进入编辑模式；<code>esc</code> 再<code>:wq</code> 是保存退出，<code>:q</code> 是退出，<code>:q!</code> 是强制退出；</li><li>Vim 查找。在 normal 模式下按下 <code>/</code> 即可进入查找模式，输入要查找的字符串并按下回车。在查找模式中加入 <code>\c</code> 表示大小写不敏感查找，<code>\C</code> 表示大小写敏感查找，例如： <code>/foo\c</code></li><li>Vim 翻页：<code>control+f</code>; <code>control+b</code></li></ul></li><li>查看开启的端口号<ul><li><code>netstat -tlnp</code></li></ul></li><li>查看当前路径<ul><li><code>pwd [-lp]</code></li></ul></li><li>查看端口号 <code>show global variables like &#39;port&#39;;</code></li><li>删除<ul><li><code>rm -rf svn/</code> 将会删除当前目录下的 svn&#x2F; 文件夹及其下所有文件夹，包括文件</li><li><code>rm -f /opt/test.txt</code> 将会强制删除 &#x2F;opt&#x2F;test.txt 这个文件</li></ul></li><li>解压文件 <code>unzip react-blog.zip</code></li><li>更换 node 版本</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin/</span><br><span class="line"><span class="comment">// 查看已有软连接：</span></span><br><span class="line">ll -all</span><br><span class="line"><span class="comment">// 删除旧node软连接</span></span><br><span class="line">rm -rf node</span><br><span class="line">rm -rf npm</span><br><span class="line">rm -rf cnpm</span><br><span class="line">cd ~</span><br><span class="line"><span class="comment">// 下载跟本地node版本相同的node</span></span><br><span class="line">wget <span class="attr">https</span>:<span class="comment">//nodejs.org/dist/v12.3.1/node-v12.3.1-linux-x64.tar.xz</span></span><br><span class="line"><span class="comment">// 解压安装包</span></span><br><span class="line">tar xvf node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64.<span class="property">tar</span>.<span class="property">xz</span></span><br><span class="line"><span class="comment">// 重建软连接</span></span><br><span class="line">ln -s /root/node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /root/node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class="line">sudo ln -s /root/node-v12<span class="number">.3</span><span class="number">.1</span>-linux-x64/bin/cnpm /usr/local/bin/cnpm</span><br></pre></td></tr></table></figure><p>更多常见命令详见 <a href="https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w">让你牛 B 加身的前端必会 Linux 命令</a><br>更多 Linux 教程也可见 <a href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程-菜鸟教程</a></p><h2 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h2><ul><li>Linux 安装 cnpm 后 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li><li>sudo 创建软连接 <code>sudo ln -s /root/node-v&lt;版本号&gt;-linux-x64/bin/cnpm /usr/local/bin/cnpm</code></li></ul><h2 id="从-Mac-本地拷贝文件到云服务器"><a href="#从-Mac-本地拷贝文件到云服务器" class="headerlink" title="从 Mac 本地拷贝文件到云服务器"></a>从 Mac 本地拷贝文件到云服务器</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>eg. 在本地命令行执行 <code>scp -r /Users/chenjunjia/React/react_blog/admin.zip root@xx.xx.xx.xx:/root/blog</code> ，再输入服务器密码即可</p><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p>参见<a href="https://blog.csdn.net/a419419/article/details/85050585">教程</a><br>eg. <code>Put React/react_blog/react-blog.zip /root/blog</code> 。注意这里的 <code>/User/chenjunjia/</code> 就被省略了（至少我的 Mac 中是这样）</p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡</p><p>目前本项目的部署其实没用到 Nginx</p><h2 id="Nginx-常见命令"><a href="#Nginx-常见命令" class="headerlink" title="Nginx 常见命令"></a>Nginx 常见命令</h2><ul><li>启动<ul><li>直接法：<code>nignx</code> 。会没有任何返回信息，这是成功状态。此时用 <code>ps aux | grep nginx</code> 看 nginx 的启动信息</li><li>用通用的 Linux 命令：<code>systemctl start nginx.service</code></li></ul></li><li>关闭<ul><li>最常用：<code>nginx -s quit</code></li><li>不常用的关闭（关闭效果等级从轻到重）：<code>nginx -s stop</code>，<code>killall nginx</code>, <code>systemctl stop nginx.service</code></li></ul></li><li>重启（修改 Nginx 文件后都要重启）<ul><li><code>nginx -s reload</code></li><li><code>systemctl restart nginx.service</code></li></ul></li></ul><h2 id="Nginx-基础配置文件"><a href="#Nginx-基础配置文件" class="headerlink" title="Nginx 基础配置文件"></a>Nginx 基础配置文件</h2><p>配置文件 <code>/etc/nginx/nginx.config</code> ，用 vim 打开后看内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">user  nginx;</span><br><span class="line"># <span class="title class_">Nginx</span>进程，一般设置为和<span class="variable constant_">CPU</span>核数一样</span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"># 错误日志存放目录</span><br><span class="line">error_log  /<span class="keyword">var</span>/log/nginx/error.<span class="property">log</span> warn;</span><br><span class="line"># 进程pid存放位置</span><br><span class="line">pid        /<span class="keyword">var</span>/run/nginx.<span class="property">pid</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  <span class="number">1024</span>; # 单个后台进程的最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.<span class="property">types</span>;   # 文件扩展名与类型映射表</span><br><span class="line">    default_type  application/octet-stream;  # 默认文件类型</span><br><span class="line">    #设置日志模式</span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /<span class="keyword">var</span>/log/nginx/access.<span class="property">log</span>  main;   # nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile        on;   # 开启高效传输模式</span><br><span class="line">    #tcp_nopush     on;    # 减少网络报文段的数量</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;  # 保持连接的时间，也叫超时时间</span><br><span class="line"></span><br><span class="line">    #gzip  on;  # 开启gzip压缩</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.<span class="property">d</span><span class="comment">/*.conf; #包含的子配置项位置和文件</span></span><br></pre></td></tr></table></figure><p>用 vim 打开 include 的子配置项文件 <code>/etc/nginx/conf.d/default.config</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;   # 配置监听端口</span><br><span class="line">    server_name  localhost;  <span class="comment">//配置域名</span></span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /<span class="keyword">var</span>/log/nginx/host.<span class="property">access</span>.<span class="property">log</span>  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;     # 服务默认启动目录</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;    # 默认访问文件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  <span class="number">404</span>              /<span class="number">404.</span>html;   # 配置<span class="number">404</span>页面</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the <span class="keyword">static</span> page /50x.<span class="property">html</span></span><br><span class="line">    #</span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.<span class="property">html</span>;   #错误状态码的显示页面。现在是这几种错误都是用现实这个html文件</span><br><span class="line">    location = /50x.<span class="property">html</span> &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cd 到 <code>/usr/share/nginx/html</code> 默认文件夹，对 index.html 默认文件编辑并保存，然后用 nginx 命令即能启动服务器。访问 ip 地址就能看到内容了</p><p>同理编辑 <code>/usr/share/nginx/html/404.html</code> 是 404 时显示的页面；也可以让 404 指向其他页面：<code>error_page 404 http://github.com;</code></p><h2 id="Nginx-实现访问控制"><a href="#Nginx-实现访问控制" class="headerlink" title="Nginx 实现访问控制"></a>Nginx 实现访问控制</h2><blockquote><p>nginx 的指令是谁写在前面就谁先生效（如果有冲突）</p></blockquote><p>只允许某个主机进行访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123; <span class="comment">// 这里的 / 是全部的意思</span></span><br><span class="line">        allow  xx.<span class="property">xx</span>.<span class="property">xx</span>.<span class="property">xx</span>;  <span class="comment">//  // 允许访问的ip</span></span><br><span class="line">        deny   all; <span class="comment">// 也可以是某个ip</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>/</code> 是全部的意思；改成 <code>=/img</code> 则是网站下的 img 目录；也可以用正则，<code>~\.php$</code></p><h2 id="Ngingx-设置虚拟机"><a href="#Ngingx-设置虚拟机" class="headerlink" title="Ngingx 设置虚拟机"></a>Ngingx 设置虚拟机</h2><p>通过设置虚拟主机，一台云服务器也能同时跑好几个 Web 服务器。配置虚拟主机可以基于端口号，基于 IP，基于域名。最常用的是基于域名设置虚拟机<br>都是改 <code>/etc/nginx/conf.d/default.config</code> 配置文件</p><h3 id="基于端口号"><a href="#基于端口号" class="headerlink" title="基于端口号"></a>基于端口号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">8001</span>;</span><br><span class="line">        server_name localhost; <span class="comment">// localhost:8001端口新开虚拟机</span></span><br><span class="line">        root /usr/share/nginx/html/html8001;</span><br><span class="line">        index index.<span class="property">html</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑 <code>/usr/share/nginx/html/html8001</code> 下的 index.html ，即可访问 8001 端口了</p><h3 id="基于端-IP"><a href="#基于端-IP" class="headerlink" title="基于端 IP"></a>基于端 IP</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xx.<span class="property">xx</span>.<span class="property">xx</span>.<span class="property">xx</span>; <span class="comment">// 某新ip</span></span><br><span class="line">        root /usr/share/nginx/html/html8001;</span><br><span class="line">        index index.<span class="property">html</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于域名（最常用）"><a href="#基于域名（最常用）" class="headerlink" title="基于域名（最常用）"></a>基于域名（最常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xxx.<span class="property">com</span>; <span class="comment">// 如果有多个域名就可以配多个</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html8001;</span><br><span class="line">                index index.<span class="property">html</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx-实现反向代理"><a href="#Nginx-实现反向代理" class="headerlink" title="Nginx 实现反向代理"></a>Nginx 实现反向代理</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>正向代理（为客户端做代理）：普通的 proxy 代理，把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做 proxy 服务器，再转发给客户。eg. 翻墙（你没有权限，但是 proxy 服务器有权限）<br><img src="/img/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png"><br>反向代理（为服务器做代理）：反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。<br><img src="/img/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png"></p><h3 id="反向代理的用途和好处"><a href="#反向代理的用途和好处" class="headerlink" title="反向代理的用途和好处"></a>反向代理的用途和好处</h3><ul><li>安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。</li><li>功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配。</li></ul><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123; <span class="comment">// 访问 nginx2.jspang.com 反向代理到 jspang.com 这个网站。所以当我们访问nginx2.jspang.com的时候呈现的是jspang.com的内容</span></span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name nginx2.<span class="property">jspang</span>.<span class="property">com</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">               proxy_pass <span class="attr">http</span>:<span class="comment">//jspang.com;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx-适配-PC-或移动设备"><a href="#Nginx-适配-PC-或移动设备" class="headerlink" title="Nginx 适配 PC 或移动设备"></a>Nginx 适配 PC 或移动设备</h2><p>大型网站，eg. 淘宝和京东的网站，根据 PC 端或移动端会有不同的站点，而不是用自适应布局。<br>用 Nginx 的 <code>$http_user_agent</code> 可以获取到客户端的 userAgent ，进而展示不同的页面给用户</p><h1 id="Linux-中搭建-MYSQL"><a href="#Linux-中搭建-MYSQL" class="headerlink" title="Linux 中搭建 MYSQL"></a>Linux 中搭建 MYSQL</h1><p>安装，搜教程</p><h2 id="Linux-操作数据库命令大全（结尾一定要带分号！）"><a href="#Linux-操作数据库命令大全（结尾一定要带分号！）" class="headerlink" title="Linux 操作数据库命令大全（结尾一定要带分号！）"></a>Linux 操作数据库命令大全（结尾一定要带分号！）</h2><p>参考自<a href="https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/10/18/2216279.html">博客 1</a>，<a href="https://blog.csdn.net/stamhe/article/details/3924638">博客 2</a></p><ul><li>开启 mysql <code>service mysqld start</code>，<code>mysql -u root</code></li><li>关闭 <code>mysql&gt; exit;</code></li><li>进入 mysql 后，使用 SHOW 语句找出在服务器上当前存在什么数据库 <code>mysql&gt; SHOW DATABASES;</code></li><li>创建一个数据库 test <code>mysql&gt; CREATE DATABASE test character set utf8;</code></li><li>选择你所创建的数据库 <code>mysql&gt; USE test;</code></li><li>使用 SHOW 语句看数据库有几个表 <code>mysql&gt; SHOW TABLES;</code></li><li>创建一个表 <code>CREATE TABLE mytable (name VARCHAR(20), sex CHAR(1),birth DATE, birthaddr VARCHAR(20));</code><br>CREATE TABLE <code>type</code> (<br><code>id</code> int(10) unsigned NOT NULL auto_increment,<br><code>flag_deleted</code> enum(‘Y’,’N’) character set utf8 NOT NULL default ‘N’,<br><code>flag_type</code> int(5) NOT NULL default ‘0’,<br><code>type_name</code> varchar(50) character set utf8 NOT NULL default ‘’,<br>PRIMARY KEY (<code>id</code>)<br>) DEFAULT CHARSET&#x3D;utf8;</li><li>显示表的结构 <code>mysql&gt; DESCRIBE mytable;</code></li><li>用 SELECT 命令来查看表中的数据 <code>mysql&gt; select * from mytable;</code></li><li>给表加入数据 <code>mysql&gt; insert into mytable values (′jacle′,′m′,′1996-02-04′,′china′);</code><br>insert into test values (2,’jacle2’);</li><li>用文本方式将数据装入一个数据库。创建一个文本文件“mysql.txt”，每行包含一个记录，用定位符(tab)把值分开，并且以在 CREATE TABLE 语句中列出的列次序给出,例如<br>abccs f 1977-07-07 china 　<br>mary f 1978-12-12 usa<br>tom m 1970-09-02 usa<br>使用下面命令将文本文件“mytable.txt”装载到 mytable 表中:<br><code>mysql&gt; LOAD DATA LOCAL INFILE &quot;/data/mytable.txt” INTO TABLE mytable;</code></li><li>修改表结构，更详见 <a href="https://www.jianshu.com/p/a6771d05ad59">博客 3</a>，其中添加字段是 <code>ALTER TABLE &lt;表名&gt; ADD &lt;字段名称&gt; &lt;字段定义&gt;</code></li><li>删除表 <code>DROP TABLE table_name ;</code></li><li>查看表的编码 <code>show create table &lt;表名&gt;;</code></li><li>修改数据库成 utf8 的 <code>mysql&gt; alter database name character set utf8;</code></li><li>修改表默认用 utf8 <code>mysql&gt; alter table type character set utf8;</code></li><li>修改字段用 utf8 <code>mysql&gt; alter table type modify type_name varchar(50) CHARACTER SET utf8;</code></li><li>更新数据 <code>UPDATE &lt;表名&gt; SET id=2 WHERE type_id=2;</code></li></ul><h2 id="一些-bug"><a href="#一些-bug" class="headerlink" title="一些 bug"></a>一些 bug</h2><p><a href="https://blog.csdn.net/lkforce/article/details/79006838">mysql 的 char，varchar，text 类型的区别总结</a><br>Linux 中 mysql 表无法写入中文，解决方法是 varchar 类型建议用 utf-8</p><h1 id="Linux-中搭建-Node-js-，npm-和-PM2"><a href="#Linux-中搭建-Node-js-，npm-和-PM2" class="headerlink" title="Linux 中搭建 Node.js ，npm 和 PM2"></a>Linux 中搭建 Node.js ，npm 和 PM2</h1><p>安装方法自行谷歌</p><h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><p>pm2 是一个带有负载均衡功能的应用进程管理器，也可以用来做进程守护。<a href="https://juejin.im/post/5be406705188256dbb5176f9">pm2 简易使用手册</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>查看进程 <code>pm2 list</code></li><li>停止所有 <code>pm2 stop all</code></li><li>运行某个 node 文件 <code>pm2 start xxx.js</code></li><li>运行项目 <code>pm2 start npm —- run start/dev</code></li><li>重启 <code>pm2 restart XXX</code></li><li>停止 <code>pm2 stop XXX</code></li><li>删除 <code>pm2 delete XXX</code></li><li>查看某个进程&#x2F;应用具体情况 <code>pm2 describe Travel</code></li><li>查看进程&#x2F;应用的资源消耗情况 <code>pm2 monit</code></li><li>查看所有日志 <code>pm2 logs (Travel)</code></li><li>查看 7001 端口的进程 （PID 就是进程 id）<code>lsof -i:7001</code></li><li>关闭进程 <code>kill -9 &lt;进程id&gt;</code></li></ul><h3 id="pm2-项目管理"><a href="#pm2-项目管理" class="headerlink" title="pm2 项目管理"></a>pm2 项目管理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;项目目录&gt;</span><br><span class="line"><span class="comment">// 在项目目录生成pm2配置文件：ecosystem.config.js。改该文件的name属性为自定义进程名字，script属性为react项目npm run start时执行的脚本（需要先npm run eject才会出现这个脚本）</span></span><br><span class="line">pm2 ecosystem</span><br><span class="line"><span class="comment">// 执行进程</span></span><br><span class="line">pm2 start ecosystem.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line"><span class="comment">// 查看执行的进程，发现会有自定义名字的进程</span></span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure><h1 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h1><blockquote><p>每次更改项目后应该先 build，再用 pm2 start；测试的时候应该用 dev</p></blockquote><h2 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h2><p>对于博客项目，前台是 Next.js 项目，拷贝之后先 <code>build</code> ，然后再 <code>pm2 start npm — run start</code> 就可以了<br>http 默认是 80 端口，可以把前台项目改成 80 端口；其次，你还要在安全组开放相关的端口才能成功访问的（其实我没做这一步）</p><h2 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h2><p>中台是 Egg.js 项目，直接 npm run start 就行（自带进程守护）。中台连接云服务器数据库方法暂时是把 <code>config.default.js</code> 改成下面如下配置，可以通过 IP 或者域名+端口号访问接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config.<span class="property">cluter</span> = &#123;</span><br><span class="line">  <span class="attr">listen</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span> <span class="comment">// 其实就是localhost</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><p>后台是 React 项目，是直接用 pm2 进行管理直接 start</p><h1 id="踩坑集合"><a href="#踩坑集合" class="headerlink" title="踩坑集合"></a>踩坑集合</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul><li>前后台项目中请求应该以服务器 ip 地址为准，而不是 localhost</li><li>数据中台的跨域设置是参考<a href="https://github.com/eggjs/egg/issues/3160">该贴</a>，最后配置如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只想让 domainWhiteList 的可以跨域，那就不用配置 origin</span></span><br><span class="line">config.<span class="property">security</span> = &#123;</span><br><span class="line">  <span class="attr">csrf</span>: &#123; <span class="attr">enable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  <span class="attr">domainWhiteList</span>: [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你要用 origin: &#x27;*&#x27; 又想带 withCredentials，配置改成这样</span></span><br><span class="line">config.<span class="property">cors</span> = &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">origin</span>: <span class="function"><span class="params">ctx</span> =&gt;</span> ctx.<span class="title function_">get</span>(<span class="string">&#x27;origin&#x27;</span>),</span><br><span class="line">  <span class="attr">allowMethods</span>: <span class="string">&#x27;GET, HEAD, PUT, POST, DELETE, PATCH, OPTIONS&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改项目默认接口"><a href="#修改项目默认接口" class="headerlink" title="修改项目默认接口"></a>修改项目默认接口</h2><ul><li>React 项目修改默认接口：<code>node_modules</code> 文件夹里的可以看到 <code>react-scripts</code> 文件夹，在 <code>start.js</code> 里可以找到修改端口的代码。直接搜索 <code>||</code></li><li>Next 项目改默认端口是直接在<code>script</code>命令最后加 <code>-p &lt;端口号&gt;</code></li></ul><h2 id="React-项目-TypeError-ERR-INVALID-ARG-TYPE-The-“path”-argument-must-be-of-type-string-Received-type-undefined"><a href="#React-项目-TypeError-ERR-INVALID-ARG-TYPE-The-“path”-argument-must-be-of-type-string-Received-type-undefined" class="headerlink" title="React 项目 TypeError [ERR_INVALID_ARG_TYPE]: The “path” argument must be of type string. Received type undefined"></a>React 项目 TypeError [ERR_INVALID_ARG_TYPE]: The “path” argument must be of type string. Received type undefined</h2><p>react-scripts 版本问题，升级到 3.4.0。果然成功了！！！哭了！</p><p>参考文章<br><a href="https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w">让你牛 B 加身的前端必会 Linux 命令-奇舞团</a><br><a href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程-菜鸟教程</a><br><a href="https://jspang.com/detailed?id=39">一个前端必会的 Nginx 免费教程-技术胖</a><br><a href="https://juejin.im/post/5be406705188256dbb5176f9">pm2 简易使用手册</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经过一番折腾之后项目终于上线了（喜极而泣，坑好多），博客项目部署在 &lt;a href=&quot;http://jacleklm.com/&quot;&gt;Jacle</summary>
      
    
    
    
    <category term="上线部署" scheme="http://jacleklm.github.io/categories/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="上线部署" scheme="http://jacleklm.github.io/tags/%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>React基本原理 &amp; 一些特性 &amp; 性能优化</title>
    <link href="http://jacleklm.github.io/2020/02/04/React%E5%B0%8F%E7%BB%93/"/>
    <id>http://jacleklm.github.io/2020/02/04/React%E5%B0%8F%E7%BB%93/</id>
    <published>2020-02-04T06:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h2><p>虚拟 DOM 本质上是 JavaScript 对象,是对真实 DOM 的抽象，状态变更时，通过 diff 算法计算出记录新树和旧树的差异，最后把差异更新到真正的 dom 中</p><h3 id="虚拟-DOM-的实现"><a href="#虚拟-DOM-的实现" class="headerlink" title="虚拟 DOM 的实现"></a>虚拟 DOM 的实现</h3><p>相较于 DOM 来说，<strong>操作 JS 对象会快很多</strong>，并且我们也可以通过 JS 来模拟 DOM</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="keyword">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>那么既然 DOM 可以通过 <strong>JS 对象来模拟</strong>，反之也可以<strong>通过 JS 对象来渲染出对应的 DOM</strong>。难点在于如何<strong>判断新旧两个 JS 对象的最小差异</strong>并且<strong>实现局部更新</strong> DOM。这就需要 Diff 算法了</p><h3 id="虚拟-DOM-真的能提升性能吗？"><a href="#虚拟-DOM-真的能提升性能吗？" class="headerlink" title="虚拟 DOM 真的能提升性能吗？"></a>虚拟 DOM 真的能提升性能吗？</h3><p>使用虚拟 DOM，<strong>在 DOM 阶段操作少了通讯的确是变高效了，但代价是在 JS 阶段需要完成额外的工作</strong>（diff 计算），这项额外的工作是需要耗时的！<br>虚拟 DOM<strong>并不是说比原生 DOM API 的操作快，而是说不管数据怎么变化，都可以以最小的代价来进行更新 DOM</strong>。在每个点上，其实用手工的原生方法会比 diff 好很多。比如说仅仅是修改了一个属性，需要整体重绘吗？显然这不是虚拟 DOM 提出来的意义。框架的意义在于掩盖底层的 DOM 操作，用更声明式的方式来描述，从而让代码更容易维护。</p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p><a href="https://zhuanlan.zhihu.com/p/20346379">详解</a><br>首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n3)。React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是<strong>只对比同层的节点，而不是跨层对比</strong>，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步</p><ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引 ，便于最后渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><p>在第一步算法中，需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 tagName 的话，就需要判断是否有子元素，有的话就进行第二步算法。<br>在第二步算法中，需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。<br>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][</span><br><span class="line">  <span class="comment">// 这里替换上面的 li</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。<br>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 key 这个属性。<strong>这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点</strong>。<br>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。<br>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。</p><h2 id="如何正确使用key"><a href="#如何正确使用key" class="headerlink" title="如何正确使用key"></a><a href="http://www.conardli.top/blog/article/React%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/React%E4%B8%ADkey%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.html#_1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8key">如何正确使用key</a></h2><h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p><a href="https://zhuanlan.zhihu.com/p/36062486">详解</a><br><img src="/img/React%E5%8E%9F%E7%90%86/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"><br>React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段:"></a>挂载阶段:</h3><ul><li>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化 state 对象或者给自定义方法绑定 this</li><li>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState),这是个静态方法,当我们接收到新的属性想去修改我们 state，可以使用 getDerivedStateFromProps</li><li>render: render 函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等内容</li><li>componentDidMount: 组件装载之后调用，此时我们可以获取到 DOM 节点并操作，比如对 canvas，svg 的操作，<strong>服务器请求，订阅</strong>都可以写在这个里面，但是记得在 componentWillUnmount 中取消订阅</li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段:"></a>更新阶段:</h3><ul><li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li><li>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState),有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利用此生命周期来优化 React 程序性能</li><li>render: 更新阶段也会触发此生命周期</li><li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState),这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，如果你不想要返回值，可以返回 null，此生命周期必须与 componentDidUpdate 搭配使用</li><li>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot),该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。</li></ul><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段:"></a>卸载阶段:</h3><ul><li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作</li></ul><h3 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h3><p>React 16 之后有三个生命周期被废弃(但并未删除)：componentWillMount，componentWillReceiveProps，componentWillUpdate</p><h3 id="周期内禁忌的事"><a href="#周期内禁忌的事" class="headerlink" title="周期内禁忌的事"></a>周期内禁忌的事</h3><ul><li>componentWillMount 里 请求数据，订阅，setState</li></ul><h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><p>ReaxtV16 版本中引入了 Fiber 机制，生命周期部分发生变化。<br>React Fiber 是一种基于浏览器的单线程调度算法.<br>React 16之前 ，diff 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归。Fiber将diff拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算<br>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新<br>异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。<br>Reconciliation 阶段</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>Commit 阶段</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。</p><ul><li>getDerivedStateFromProps 用于替换 componentWillReceiveProps ，该函数会在初始化和 update 时被调用</li><li>getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。</li></ul><h2 id="setState-机制"><a href="#setState-机制" class="headerlink" title="setState 机制"></a>setState 机制</h2><p>PS: useState 它不香吗</p><h3 id="理想情况："><a href="#理想情况：" class="headerlink" title="理想情况："></a>理想情况：</h3><p>setState 是“异步”的，调用 setState 只会提交一次 state 修改到队列中，不会直接修改 this.state，等到满足一定条件时，react 会合并队列中的所有修改，触发一次 update 流程，更新 this.state。因此 setState 机制减少了 update 流程的触发次数，从而提高了性能。所以会有以下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化 `count` 为 0</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以通过以下方式来实现调用三次 setState 使得 count 为 3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span> &#125;))</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 setState 会触发 update 过程，因此在 update 过程中必经的生命周期中调用 setState 会存在循环调用的风险。</p><p>另外用于监听 state 更新完成，可以使用 setState 方法的第二个参数，回调函数。在这个回调中读取 this.state 就是已经批量更新后的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span> &#125;), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h3><p>在实际开发中，setState 的表现有时会不同于理想情况。主要是以下两种</p><ul><li>在 mount 流程中调用 setState。</li><li>在 setTimeout&#x2F;Promise 回调中调用 setState。</li></ul><p>在第一种情况下，不会进入 update 流程，队列在 mount 时合并修改并 render<br>在第二种情况下，setState 将不会进行队列的批更新，而是直接触发一次 update 流程。这是由于 setState 的两种更新机制导致的，只有在批量更新模式中，才会是“异步”的。</p><h2 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h2><p><a href="https://juejin.im/post/5bd32493f265da0ae472cc8e">更详细的源码解析版</a><br>React 其实自己实现了一套事件机制，首先我们考虑一下以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params">&#123; list, handleClick &#125;</span>) =&gt; (&#123;</span><br><span class="line">    list.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;index&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    ))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的点击事件是否绑定在了每一个标签上？当然不是，JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过<strong>事件代理</strong>的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p><p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此在React中，用 return false阻止默认行为，而应该在事件处理程序中调用 event.preventDefault 或 event.stopPropagation 来阻止冒泡（所以也不会有兼容性问题）</p><p>合成事件的优点</p><ul><li>抹平了浏览器之间的兼容问题</li><li>性能优化。对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象</li></ul><h1 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h1><h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><p><a href="https://jacleklm.github.io/2019/12/29/React%E7%BB%84%E4%BB%B6/">见此博文</a></p><h2 id="React-Router-React-Redux"><a href="#React-Router-React-Redux" class="headerlink" title="React Router &amp; React Redux"></a>React Router &amp; React Redux</h2><p><a href="https://jacleklm.github.io/2020/01/04/React%E8%B7%AF%E7%94%B1%20&%20Redux/">见此博文</a></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><ul><li>父子组件通信：单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过调用父组件函数的方式告知父组件修改数据</li><li>兄弟组件通信：可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</li><li>跨多层次组件通信<ul><li><a href="https://zh-hans.reactjs.org/docs/context.html">Context API</a>。此外，还可以通过 context 传递一个函数，使得 consumers 组件更新 context<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Context，可以在开始就传入值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StateContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// value 就是传入 Context 中的值</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">StateContext.Provider</span> <span class="attr">value</span>=<span class="string">&#x27;yck&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">StateContext.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // 取出值</span></span><br><span class="line"><span class="language-xml">        &#123;context =&gt; (</span></span><br><span class="line"><span class="language-xml">          name is &#123; context &#125;</span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">useContext</a>不香吗，其实是同理的</li></ul></li><li>任意组件：Redux等状态管理工具 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</li></ul><h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a><a href="https://zh-hans.reactjs.org/docs/render-props.html">render props</a></h2><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>react 中性能主要耗费在于 update 阶段的 diff 算法，因此性能优化也主要是减少 diff 算法触发次数</p><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p>setState 机制在正常运行时，由于批更新策略，已经降低了 update 过程的触发次数。<br>因此，setState 优化主要在于非批更新阶段中(timeout&#x2F;Promise 回调)，减少 setState 的触发次数。<br>常见的业务场景即处理接口回调时，无论数据处理多么复杂，保证最后只调用一次 setState</p><h2 id="父组件-Render"><a href="#父组件-Render" class="headerlink" title="父组件 Render"></a>父组件 Render</h2><p>当组件的 state 或 props 变化时，自身 render() 会重新执行<br>父组件的 render 必然会触发子组件 render，子组件会进入 update 阶段（无论 props 是否更新）</p><ul><li>此时最常用的优化方案即为 shouldComponentUpdate 方法。在 shouldComponentUpdate 函数中我们可以通过返回布尔值来决定当前组件是否需要更新，一般来说不推荐完整地对比当前 state 和之前的 state 是否相同，一般只比较 stated 某个或某几个值。最常见的方式为进行 this.props 和 this.state 的浅比较来判断组件是否需要更新，如下，组件只有当 props.color 或者 state.count 的值改变才会更新</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">color</span> !== nextProps.<span class="property">color</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> !== nextState.<span class="property">count</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>PureComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>或者直接使用 PureComponent，原理一致</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>PureComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数组件用不了 shouldComponentUpdate，可以使用 React.memo 来实现相同的功能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>PureComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><h2 id="DOM-操作方面减少-diff"><a href="#DOM-操作方面减少-diff" class="headerlink" title="DOM 操作方面减少 diff"></a>DOM 操作方面减少 diff</h2><ul><li>不使用跨层级移动节点的操作</li><li>对于条件渲染多个节点时，尽量采用隐藏等方式切换节点，而不是替换节点</li><li>尽量避免将后面的子节点移动到前面的操作，当节点数量较多时，会产生一定的性能问题</li></ul><h1 id="React的优点"><a href="#React的优点" class="headerlink" title="React的优点"></a>React的优点</h1><h2 id="React速度很快"><a href="#React速度很快" class="headerlink" title="React速度很快"></a>React速度很快</h2><p>它并不直接对DOM进行操作，引入了一个叫做虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能好。最大限度减少DOM交互。</p><h2 id="跨浏览器兼容"><a href="#跨浏览器兼容" class="headerlink" title="跨浏览器兼容"></a>跨浏览器兼容</h2><p>虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的</p><h2 id="一切都是component"><a href="#一切都是component" class="headerlink" title="一切都是component"></a>一切都是component</h2><p>代码更加模块化，重用代码更容易，可维护性高。这样当某个或某些组件出现问题是，可以方便地进行隔离。每个组件都可以进行独立的开发和测试，并且它们可以引入其它组件。这等同于提高了代码的可维护性。</p><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。减少了重复代码，这也是它为什么比传统数据绑定更简单。</p><h2 id="同构、纯粹的javascript"><a href="#同构、纯粹的javascript" class="headerlink" title="同构、纯粹的javascript"></a>同构、纯粹的javascript</h2><p>因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</p><h2 id="兼容性好"><a href="#兼容性好" class="headerlink" title="兼容性好"></a>兼容性好</h2><p>比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。Vue 首先考虑的是假设用户只掌握了 web 基础知识 (HTML, CSS, JS) 的情况下，如何能够最快理解和上手，实现一个看得见摸得着的应用</p><h1 id="React设计模式"><a href="#React设计模式" class="headerlink" title="React设计模式"></a>React设计模式</h1><p>见<a href="https://sangka.github.io/react-in-patterns-cn/chapter-2/">React模式</a>。这篇文章写的非常好，观点简明扼要。看完想写一篇笔记发现这篇文章已经总结的很精简了，直接多看几遍吧吧233</p><blockquote><p>单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已</p></blockquote><p>参考资料<br><a href="https://segmentfault.com/a/1190000015648248">react 基本原理及性能优化</a><br><a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html">React 官方文档-性能优化</a><br><a href="https://zhuanlan.zhihu.com/p/36062486">React v16.3 版本新生命周期函数浅析及升级方案</a><br>前端面试之道<br><a href="https://juejin.im/post/5bd32493f265da0ae472cc8e">React事件机制源码解析</a><br><a href="http://www.conardli.top/blog/">conardli</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;h2 id=&quot;Virtual-Dom&quot;&gt;&lt;a href=&quot;#Virtual-Dom&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://jacleklm.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>博客项目小结</title>
    <link href="http://jacleklm.github.io/2020/01/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/"/>
    <id>http://jacleklm.github.io/2020/01/29/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/</id>
    <published>2020-01-29T07:49:21.000Z</published>
    <updated>2023-09-17T14:00:22.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>该项目是<a href="https://jspang.com/">技术胖</a>的一个项目，涉及了前台中台后台，觉得是个不错的练手项目.</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>博客前台： React Hooks + Next.js + marked + highlight + Ant Design<br>数据中台： Egg.js（阿里的一个基于 Koa2 的框架） + MySQL<br>管理后台： React Hooks + Ant Design （不用 Next.js）</p><blockquote><p>Next.js 是一个轻量级的 React 服务端渲染应用框架。有了它我们可以简单轻松的实现 React 的服务端渲染，从而加快首屏打开速度，也可以作 SEO（搜索引擎优化了）。并且路由，webpack 配置等也是框架配置好的。<br>个人看法：配置太全了，自己写着玩的项目还好，企业级的项目用起来可能不够灵活。</p></blockquote><h1 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>组件内的布局基本都是用 Antd 的 栅格-响应式布局 ，<code>&lt;Col&gt;</code> 的 xs，sm 等这些属性本质上是媒介查询；给 <code>&lt;Row&gt;</code> 添加属性实现 flex 布局 <code>type=&quot;flex&quot; justify=&quot;center&quot;</code></p><p>组件一般都是用 Antd 的组件组合而成</p><h2 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h2><p>数据来源于请求中台接口</p><h3 id="函数组件的-getInitialProps-方法写一个-promise-并返回-promise-的结果（Next-js-框架）"><a href="#函数组件的-getInitialProps-方法写一个-promise-并返回-promise-的结果（Next-js-框架）" class="headerlink" title="函数组件的 getInitialProps 方法写一个 promise 并返回 promise 的结果（Next.js 框架）"></a>函数组件的 <code>getInitialProps</code> 方法写一个 promise 并返回 promise 的结果（Next.js 框架）</h3><p><a href="https://nextjs.frontendx.cn/docs/#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%8F%8A%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">文档</a><br>该方法返回的应该是一个普通的 JS 对象；不能用于子组件中，只能用于 pages 页面组件中；该方法只会加载在服务端，所以在该方法中 console 是不会显示的；</p><p>该方法用于一开始就请求一次的数据（之后不用请求了），然后 promise 的 resolve 的结果这个对象，会变成函数组件的 props 对象。例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [mylist, setMylist] = <span class="title function_">useState</span>(props.<span class="property">data</span>)</span><br><span class="line">  <span class="comment">// ...组件逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件外</span></span><br><span class="line"><span class="title class_">Home</span>.<span class="property">getInitialProps</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(servicePath.<span class="property">getArticleList</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>) <span class="comment">// resovle()的结果这个对象变成上面的props对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法其实和写在最普通的 useEffect 的写法效果一样</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>中台安装 egg-cors ，并做相应配置。本质是设置 Access-Control-Allow-Origin</p><h3 id="跨域白名单"><a href="#跨域白名单" class="headerlink" title="跨域白名单"></a>跨域白名单</h3><p><em>Egg.js 的跨域不支持白名单，只支持单个域名，这样前后台项目不能一起跑。解决方案是需要自己写一个中间件实现白名单，这是别人写的<a href="https://www.jianshu.com/p/fa5f80924e97">中间件</a>，<a href="https://github.com/temool/egg-origin">Github</a>，这里直接用了这个中间件</em></p><blockquote><p>最后线上版本舍弃了这个插件，见博客项目上线部署博文的 跨域</p></blockquote><h2 id="涉及-id-的页面"><a href="#涉及-id-的页面" class="headerlink" title="涉及 id 的页面"></a>涉及 id 的页面</h2><p>像不同种类的列表页，文章详情页这种涉及 id 的页面，路由设置 和 数据获取 稍微复杂一些</p><p>例如，列表页中每篇文章的标题，是一个带 id 的 <code>&lt;Link&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-title&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;&#123;</span> <span class="attr">pathname:</span> &#x27;/<span class="attr">detailed</span>&#x27;, <span class="attr">query:</span> &#123; <span class="attr">id:</span> <span class="attr">item.id</span> &#125; &#125;&#125;&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击后跳转带详情页，所以详情页的 <code>getInitialProps</code> 获取数据的时候是根据路由的 id 去 post</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Detailed</span>.<span class="property">getInitialProps</span> = <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> id = context.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(servicePath.<span class="property">getArticleById</span> + id).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>.<span class="property">data</span>[<span class="number">0</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的接口则是由文章的 id 在数据库查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getArticleById</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">&#x27;SELECT article.id as id,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.title as title,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.introduce as introduce,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.article_content as article_content,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;article.view_count as view_count ,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;type.typeName as typeName ,&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;type.id as typeId &#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;FROM article LEFT JOIN type ON article.type_id = type.Id &#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;WHERE article.id=&#x27;</span> + id;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">query</span>(sql);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">body</span> = &#123; <span class="attr">data</span>: result &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>PS：前端在路由跳转的时候（<code>Router.push()</code> 或 <code>&lt;Link href=‘xx’&gt;</code>)，路由地址最后得是 <code>xx?id=1</code> 这样，而不是 <code>xx/?id=1</code>。但是后端在配置接口的时候依旧是 <code>xx/:id</code></p><h2 id="详情页-中对-Markdown-语法的解析"><a href="#详情页-中对-Markdown-语法的解析" class="headerlink" title="详情页 中对 Markdown 语法的解析"></a>详情页 中对 Markdown 语法的解析</h2><p>把从数据库取出来的 markdown 语法的字符串，编译成正常的文章并显示样式，是用 <a href="https://github.com/markedjs/marked">marked</a> + <a href="https://github.com/highlightjs/highlight.js/">heighlight.js</a></p><h2 id="详情页-中的-导航目录组件"><a href="#详情页-中的-导航目录组件" class="headerlink" title="详情页 中的 导航目录组件"></a>详情页 中的 导航目录组件</h2><p>效果如下所示：<br><img src="/img/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6.png"><br>把这个组件固定在页面右侧是用了 Antd 的 Affix 固钉 组件，Anchor 锚点</p><p>解析文章内容生成目录是用了阿里的一个插件 tocify.tsx</p><h1 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h1><h2 id="概况-RESTful-规范"><a href="#概况-RESTful-规范" class="headerlink" title="概况 &amp; RESTful 规范"></a>概况 &amp; RESTful 规范</h2><p>配置了两套路由，<code>/default/</code>开头的用于前台，<code>/admin/</code>开头的用于后台<br>所有数据的获得和业务逻辑的操作都是通过中台实现的，也就是说中台只提供接口，这里的设计我们采用 RESTful 的规则，让 egg 为前端提供 Api 接口，实现中台主要的功能</p><blockquote><p>RESTful 是目前最流行的网络应用程序设计风格和开发方式，大量使用在移动端 App 上和前后端分离的接口设计。这种形式更直观并且接口也有了一定的约束性。</p></blockquote><p>约束的请求方式和对应的操作:</p><ul><li>GET(SELECT) ： 从服务端取出资源，可以同时取出一项或者多项。</li><li>POST(CREATE) ：在服务器新建一个资源。</li><li>PUT(UPDATE) ：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>DELETE(DELETE) ：从服务器删除资源。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库采用的是关系型数据库 MySQL，安装了官方带的 WorkBench 对数据库进行可视化管理。把 Egg.js 项目进行连接数据库的配置后即能使用</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>表 和 Cloum 如下：</p><ul><li><p>type</p><ul><li>id : 类型编号 int 类型</li><li>typeName: 文章类型名称 varchar 类型</li><li>orderNum: 类型排序编号 int 类型</li></ul></li><li><p>article</p><ul><li>id : 文章编号 int 类型</li><li>type_id : 文章类型编号 int 类型</li><li>title : 文章标题，varchar 类型</li><li>article_cointent : 文章主体内容，text 类型， TEXT(n)，这里的 n 是文本长度，可以设置一个较大值</li><li>introduce： 文章简介，text 类型</li><li>addTime : 文章发布时间，int(11)类型</li><li>view_count ：浏览次数， int 类型</li></ul></li><li><p>admin_user</p><ul><li>id</li><li>userName</li><li>password</li></ul></li></ul><h3 id="数据库语法"><a href="#数据库语法" class="headerlink" title="数据库语法"></a>数据库语法</h3><p>参考<br><a href="https://www.w3school.com.cn/sql/sql_join_left.asp">W3School</a><br><a href="https://www.cnblogs.com/cathyqq/p/5197626.html">SQL 时间戳日期时间转换</a></p><blockquote><p>常用例子</p></blockquote><ul><li>增，直接对某个表进行 insert</li><li>删，直接根据 id，对某个表进行 delete</li><li>改，直接对某个表进行 udate</li><li>查，eg：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;SELECT article.id as id, article.title as title, article.article_content as article_content, FROM_UNIXTIME(article.addTime,&#x27;</span>%Y-%m-%d<span class="string">&#x27; ) as addTime, type.typeName as typeName, FROM article LEFT JOIN type ON article.type_id = type.Id ORDER BY article.addTime DESC&#x27;</span>; <span class="comment">// DESC是逆序的意思，ASC是正序`</span></span><br><span class="line">也可以加<span class="string">`&#x27;WHERE type_id= 2`</span> 这样的语法</span><br></pre></td></tr></table></figure><h1 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h1><p>直接用 React + Antd 写的，不用 Next.js</p><p>React 项目中的根目录的 index.js 应该是渲染一个路由组件（自己配的），由这个路由组件再去加载其他页面组件。例如路由组件可以如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;./Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AdminIndex</span> <span class="keyword">from</span> <span class="string">&#x27;./AdminIndex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/login/&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Login&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/index/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AdminIndex&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Main</span></span><br></pre></td></tr></table></figure><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>样式上比较简单，是由 Antd 的 Card, Input, Icon, Button, Spin, message 组件写的</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>目前没有 注册 这个操作，用户名密码及 id 是采用直接在 workbench 插入新数据的方式注册<br>点击登录按钮的时候，向接口 post 用户名和密码，向数据库查询这个用户名和密码。如果登录成功就返回登录成功的信息和一个 token，组件就把 token 存到 localstorage 中（<code>localStorage.setItem(&#39;openId&#39;, res.data.openId)</code>），并跳转到首页（<code>props.history.push(&#39;/index&#39;)</code>）</p><p>附上接口代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断用户名密码是否正确</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">checkLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> userName = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">request</span>.<span class="property">body</span>.<span class="property">userName</span>;</span><br><span class="line">    <span class="keyword">const</span> password = <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">request</span>.<span class="property">body</span>.<span class="property">password</span>; <span class="comment">// 这里也可以进行加密和解密</span></span><br><span class="line">    <span class="keyword">const</span> sql = <span class="string">&quot; SELECT userName FROM admin_user WHERE userName = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">mysql</span>.<span class="title function_">query</span>(sql);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 登录成功,进行session缓存</span></span><br><span class="line">      <span class="keyword">const</span> openId = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(); <span class="comment">// 传给前端的token，用当前时间的时间戳做token</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">session</span>.<span class="property">openId</span> = &#123; openId &#125;; <span class="comment">// 并且把这个token放到session中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">body</span> = &#123; <span class="attr">data</span>: <span class="string">&#x27;登录成功&#x27;</span>, openId &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">body</span> = &#123; <span class="attr">data</span>: <span class="string">&#x27;登录失败&#x27;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>登录后，我们生成了 session，通过后台是不是存在对应的 session，作一个中台的路由守卫。如果没有登录，是不允许访问后台对应的接口，也没办法作对应的操作。这样就实现了接口的安全<br>其实就是路由守卫，没有 token 的时候不让访问接口（等同于不让访问某些页面）。在这里我们是通过 egg.js 的中间件实现的（详情版见<a href="https://jspang.com/detailed?id=52#toc2123">教程</a>)</p><ul><li>写一个中间件文件，并应用在中台路由中 （目前只有<code>getTypeInfo</code>这个接口有守卫</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">adminauth</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">session</span>.<span class="property">openId</span>)</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="property">session</span>.<span class="property">openId</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.<span class="property">body</span> = &#123; <span class="attr">data</span>: <span class="string">&#x27;没有登录&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中台路由：对某个接口进行路由守卫</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getTypeInfo&#x27;</span>, adminauth, controller.<span class="property">admin</span>.<span class="property">main</span>.<span class="property">getTypeInfo</span>)</span><br></pre></td></tr></table></figure><ul><li>在正常情况下前后台是不能共享<code>session</code>的，需要要在 egg 端的<code>/config/config.default.js</code>里的<code>config.cor</code>配置项增加<code>credentials:true</code>；并且前台的请求中，需要带 <code>withCredentials: true</code>。</li></ul><h2 id="管理页"><a href="#管理页" class="headerlink" title="管理页"></a>管理页</h2><p>布局上用 Antd 的 <a href="https://ant.design/components/layout-cn/">layout-侧边布局</a>。再做相应的路由配置就能分页</p><h2 id="管理页之添加文章"><a href="#管理页之添加文章" class="headerlink" title="管理页之添加文章"></a>管理页之添加文章</h2><p>直接在 编辑文章 分页进行编辑并保存<br>前端：把文章的数据都打包好之后 POST 给后端接口<br>后端：数据库对表进行插入数据的操作。id 方面是先找到最大 id，然后让新文章的 id 等于最大值+1</p><h2 id="管理页之修改文章"><a href="#管理页之修改文章" class="headerlink" title="管理页之修改文章"></a>管理页之修改文章</h2><p>在 文章列表 分页，点击某篇文章的 修改 按钮，就会进行路由跳转到 编辑文章 分页并附上文章 id 保存在路由中</p><p>所以在 编辑文章 分页还有这样一个逻辑：有一个<code>getArticleById</code>方法，会根据 id 向接口请求对应的文章的数据并显示在页面上，这个方法会在 useEffect 中执行让它在页面刚刷新的时候就执行（如果路由有带 id 的话）。此外，改页面的 发布文章 这个按钮也会判断是否有 id，无的话就是请求发布文章的接口，有的话就是请求更新文章的接口</p><h1 id="项目优化计划"><a href="#项目优化计划" class="headerlink" title="项目优化计划"></a>项目优化计划</h1><h2 id="前台-1"><a href="#前台-1" class="headerlink" title="前台"></a>前台</h2><ul><li><input disabled="" type="checkbox"> markdown 语法中图片的解析和存储<br>markdown 语法中图片是直接写成 <code>![](/img/二叉树的遍历/二叉树的遍历_1.png)</code> 这种形式，完全不做配置的话会出现下图这种 404 的情况<br><img src="/img/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/img.png"></li><li><input disabled="" type="checkbox"> 文章简介的实现</li><li><input disabled="" type="checkbox"> 访问人数的实现。目前的访问人数是随机生成的</li><li><input disabled="" type="checkbox"> UI 美化</li></ul><h2 id="后台-1"><a href="#后台-1" class="headerlink" title="后台"></a>后台</h2><ul><li><input disabled="" type="checkbox"> 登录账号和密码加密</li><li><input disabled="" type="checkbox"> 实现手机号注册？或者说这种管理中台一般是管理者才能使用，管理者账号直接写在数据库就行了，不必要有注册功能</li><li><input disabled="" type="checkbox"> 页面 UI 优化，使该系统美观一些</li><li><input disabled="" type="checkbox"> 添加文章能插入图片</li></ul><h1 id="上线及部署"><a href="#上线及部署" class="headerlink" title="上线及部署"></a>上线及部署</h1><p>见另一篇文章</p><p>参考资料<br><a href="https://jspang.com/">技术胖博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;来源&quot;&gt;&lt;a href=&quot;#来源&quot; class=&quot;headerlink&quot; title=&quot;来源&quot;&gt;&lt;/a&gt;来源&lt;/h2&gt;&lt;p&gt;该项目</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="项目小结" scheme="http://jacleklm.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>React Router &amp; Redux</title>
    <link href="http://jacleklm.github.io/2020/01/04/React%E8%B7%AF%E7%94%B1%20&amp;%20Redux/"/>
    <id>http://jacleklm.github.io/2020/01/04/React%E8%B7%AF%E7%94%B1%20&amp;%20Redux/</id>
    <published>2020-01-04T06:50:21.000Z</published>
    <updated>2023-09-17T14:00:22.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h1><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>前端路由的本质是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面，核心是<strong>改变视图的同时不会向后端发出请求</strong>。目前前端使用的路由就只有两种实现方式:<br>Hash 模式和 History 模式</p><h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p>Vue-router 默认是 hash 模式</p><ul><li><a href="http://www.test.com/#/">www.test.com/#/</a> 就是 Hash URL（有 &#x2F;#&#x2F; 就是），当 # 后面的哈希值发生变化时</li><li><strong>hash 的修改不会导致浏览器刷新，因为</strong> window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中</li><li>所以我们可以通过 hashchange 事件来监听到 URL 的变化，写一些逻辑进行组件替换实现更新页面的效果；同时浏览器监听到 hash 变化，会把更新历史记录，并且按后退键能回到上个位置</li><li>*无论哈希值如何变化，服务端接收到的 URL 请求永远是 <a href="http://www.test.com/">www.test.com</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hash 模式优点：</p><ul><li>简单，兼容性也更好（ie8）</li><li>不需要服务器端进行任何设置和开发</li><li>除了资源加载和ajax请求以外，不会发起其他请求</li></ul><p>缺点：</p><ul><li>不太美观</li><li>对于部分需要重定向的操作，后端无法获取hash部分内容，导致后台无法取得url中的数据，典型的例子就是微信公众号的oauth验证</li><li>服务器端无法准确跟踪前端路由信息</li><li>对于需要锚点功能的需求会与目前路由机制冲突</li></ul><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。<br>通过 History 模式改变 URL 同样<strong>不会引起页面的刷新，只会更新浏览器的历史记录</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增历史记录</span></span><br><span class="line">history.<span class="title function_">pushState</span>(stateObject, title, <span class="variable constant_">URL</span>) <span class="comment">// 前两个参数可以写成null，url必须是同源的</span></span><br><span class="line"><span class="comment">// 替换当前历史记录</span></span><br><span class="line">history.<span class="title function_">replaceState</span>(stateObject, title, <span class="variable constant_">URL</span>)</span><br></pre></td></tr></table></figure><p>当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">state</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h3><p>history 的优点：</p><ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>pushState() 可额外设置 title 属性供后续使用</li></ul><p>history 的缺点：一是兼容性，二是需要后端的支持，当真正想输入 url 发起 http 请求的时候，eg. 用户手动输入 URL 后回车</p><ul><li>hash 模式下，仅 # 之前的内容会被包含在请求中，所以对后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误</li><li>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.abc.com/book/id%E3%80%82%E5%A6%82%E6%9E%9C%E5%90%8E%E7%AB%AF%E7%BC%BA%E5%B0%91%E5%AF%B9">http://www.abc.com/book/id。如果后端缺少对</a> &#x2F;book&#x2F;id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>感觉 React 的路由比 Vue 的路由更复杂些<br>exect 的区别<br><code>&lt;Route&gt;</code>,<code>&lt;Router&gt;</code>,<code>&lt;Route&gt;</code>, <a href="https://juejin.im/post/5d53e885f265da03bc1270ee">https://juejin.im/post/5d53e885f265da03bc1270ee</a> 。应该确实是组件被<Route>包裹和 withRouter 是等价的<br>props.history.push()</p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个 Store。</li><li>State：Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store 生成快照，这种时点的数据集合，就叫做 State。</li><li>Action：State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</li><li>Action Creator：View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦，所以我们定义一个函数来生成 Action，这个函数就叫 Action Creator。</li><li>Reducer：Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</li><li>dispatch：是 View 发出 Action 的唯一方法。</li></ul><p>然后我们过下整个工作流程：</p><ul><li>首先，用户（通过 View）发出 Action，发出方式就用到了 dispatch 方法。</li><li>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State</li><li>State 一旦有变化，Store 就会调用监听函数，来更新 View。</li></ul><p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。<br><img src="/img/React%E5%8E%9F%E7%90%86/Redux.png"></p><h2 id="react-redux-工作流程"><a href="#react-redux-工作流程" class="headerlink" title="react-redux 工作流程"></a>react-redux 工作流程</h2><ul><li>Provider: Provider 的作用是从最外部封装了整个应用，并向 connect 模块传递 store</li><li>connect: 负责连接 React 和 Redux<ul><li>获取 state: connect 通过 context 获取 Provider 中的 store，通过 store.getState()获取整个 store tree 上所有 state</li><li>包装原组件: 将 state 和 action 通过 props 的方式传入到原组件内部 wrapWithConnect 返回一个 ReactComponent 对象 Connect，Connect 重新 render 外部传入的原组件 WrappedComponent，并把 connect 中传入的 mapStateToProps, mapDispatchToProps 与组件上原有的 props 合并后，通过属性的方式传给 WrappedComponent</li><li>监听 store tree 变化: connect 缓存了 store tree 中 state 的状态,通过当前 state 状态和变更前 state 状态进行比较,从而确定是否调用 this.setState()方法触发 Connect 及其子组件的重新渲染</li></ul></li></ul><p><img src="/img/React%E5%8E%9F%E7%90%86/React-redux.png"></p><h2 id="Redux-VS-Mobx"><a href="#Redux-VS-Mobx" class="headerlink" title="Redux VS Mobx"></a>Redux VS Mobx</h2><p>两者对比:</p><ul><li>redux 将数据保存在单一的 store 中，mobx 将数据保存在分散的多个 store 中</li><li>redux 使用 plain object 保存数据，需要手动处理变化后的操作；mobx 适用 observable 保存数据，数据变化后自动处理响应的操作</li><li>redux 使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx 中的状态是可变的，可以直接对其进行修改</li><li>mobx 相对来说比较简单，在其中有很多的抽象，mobx 更多的使用面向对象的编程思维；redux 会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li><li>mobx 中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而 redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li></ul><p>场景辨析:</p><ul><li>mobx 更适合数据不复杂的应用: mobx 难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.mobx 适合短平快的项目: mobx 上手简单,样板代码少,可以很大程度上提高开发效率.</li><li>redux 适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于 redux 不可变的特性，天然支持这些操作.</li></ul><p>参考资料<br><a href="https://juejin.im/post/5d5f44dae51d4561df7805b4#heading-12">高频 React 面试题及详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-Router&quot;&gt;&lt;a href=&quot;#React-Router&quot; class=&quot;headerlink&quot; title=&quot;React Router&quot;&gt;&lt;/a&gt;React Router&lt;/h1&gt;&lt;h2 id=&quot;路由原理&quot;&gt;&lt;a href=&quot;#路由原理&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://jacleklm.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="http://jacleklm.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
